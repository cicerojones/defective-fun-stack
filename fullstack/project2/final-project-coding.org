* prepare successful org and db interaction 
** get correct working directory
#+BEGIN_SRC python :session *Python* :results output
# import os

os.getcwd()
#+END_SRC

#+RESULTS:
: 
: >>> '/Users/a/Documents/working-directory/udacity-courses/fullstack/project2'

#+BEGIN_SRC python :session *Python* :results output
os.chdir('/Users/a/Documents/working-directory/udacity-courses/fullstack/project2')
#+END_SRC

#+RESULTS:

** use function from development module
must be loaded in the environment first before calling from org mode?

#+BEGIN_SRC python :session *Python* :results output
import queries_for_tournament
#+END_SRC

#+RESULTS:
: [(1, 'Bill Borzo                         ', 0, 0), (2, 'Jeff Jeffries                      ', 0, 0), (3, 'Dave Davies                        ', 0, 0), (4, 'Steve Stevens                      ', 0, 0)]

#+BEGIN_SRC python :session *Python* :results output
queries_for_tournament.doDB()
#+END_SRC




#+RESULTS:
: (1, 'Bill Borzo                         ')
: (2, 'Jeff Jeffries                      ')
: (3, 'Dave Davies                        ')
: (4, 'Steve Stevens                      ')

#+RESULTS:
: (1, 'Bill Borzo                         ')
: (2, 'Jeff Jeffries                      ')
: (3, 'Dave Davies                        ')
: (4, 'Steve Stevens                      ')

** define simple function from org file
#+BEGIN_SRC python :session *Python* :results output
import os

def printwtf():
    my_dir = os.getcwd()
    print my_dir

#+END_SRC

#+RESULTS:
** call simple function defined in org file
#+BEGIN_SRC python :session *Python* :results output
printwtf()
#+END_SRC

#+RESULTS:
: /Users/a/Documents/working-directory/udacity-courses/fullstack/project2
** import statement
#+BEGIN_SRC python :session *Python* :results output
import psycopg2
#+END_SRC

#+RESULTS:

** 
** define db function from org file
*** defining these functions from org-babel block seems to be a problem?
need the blank line after the print statement in the for loop
[[*showAllPLayers--"select * from players1;"][compare against showAllPLayers--"select * from players1;"]]
#+BEGIN_SRC python :session *Python* :results output
# not complete function? what is complete
# i.e. query is commented out
def showAllPLayers():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
#    query = "select * from "
    c.execute(query)
    rows = c.fetchall()
    # print rows
    for row in rows:
        print row
    DB.close()


#+END_SRC

#+RESULTS:
: 
: >>> >>> ... ... ... ... ... ... ... ... ... ...   File "<ipython-input-89-6fc265d1c009>", line 10
:     DB.close()
:               ^
: IndentationError: unindent does not match any outer indentation level
: 
: If you want to paste code into IPython, try the %paste and %cpaste magic functions.

** call db function from org file
#+BEGIN_SRC python :session *Python* :results output
showAllPLayers()
#+END_SRC

#+RESULTS:
: (218, 'Fluttershy', 0, 1)
: (217, 'Twilight Sparkle', 1, 1)
: (220, 'Pinkie Pie', 0, 1)
: (219, 'Applejack', 1, 1)

: (1, 'Bill Borzo                         ', 0, 0)
: (2, 'Jeff Jeffries                      ', 0, 0)
: (3, 'Dave Davies                        ', 0, 0)
: (4, 'Steve Stevens                      ', 0, 0)

** empty rows of content--plain sql statements?
#+BEGIN_SRC sql
delete from matches2; delete from players2;
#+END_SRC

** add data to table

* initial 'directory' for developing python-sql functions
** model database interaction--select and printout
** install rows
*** addStandardPlayers
#+BEGIN_SRC python :session *Python* :results output
def addStandardPlayers():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    query = "insert into players1 values(1, 'Bill Borzo', 0, 0); insert into players1 values(2, 'Jeff Jeffries', 0, 0); insert into players1 values(3, 'Dave Davies', 0, 0); insert into players1 values(4, 'Steve Stevens', 0, 0);"
    c.execute(query)
    DB.commit()
    DB.close()

#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql
insert into players2 values('Bill Borzo', 0, 0); insert into players2 values('Jeff Jeffries', 0, 0); insert into players2 values('Dave Davies', 0, 0); insert into players2 values('Steve Stevens', 0, 0);
#+END_SRC
#+BEGIN_SRC python :session *Python* :results output
addStandardPlayers()
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python :session *Python* :results output
def addStandardPlayers():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    query = "insert into players1 values(1, 'Bill Borzo', 0, 0); insert into players1 values(2, 'Jeff Jeffries', 0, 0); insert into players1 values(3, 'Dave Davies', 0, 0); insert into players1 values(4, 'Steve Stevens', 0, 0);"
    c.execute(query)
    DB.close()

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
addStandardPlayers()
#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "<stdin>", line 5, in addStandardPlayers
: psycopg2.IntegrityError: duplicate key value violates unique constraint "players1_pkey"
: DETAIL:  Key (pid)=(1) already exists.

** create and call a function from orgmode?
if psycopg2 has already been imported above, need not be imported again.
#+BEGIN_SRC python :session *Python* :results output
# import psycopg2


def show_all():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    query = "select * from players1;"
    c.execute(query)
    rows = c.fetchall()
    for row in rows:
        print row
	
    DB.close()

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
show_all()
#+END_SRC

#+RESULTS:
: (1, 'Bill Borzo                         ', 0, 0)
: (2, 'Jeff Jeffries                      ', 0, 0)
: (3, 'Dave Davies                        ', 0, 0)
: (4, 'Steve Stevens                      ', 0, 0)

** delete Rows
*** 1
#+BEGIN_SRC python :session *Python* :results output
def deleteRows():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    query = "delete from players1;"
    c.execute(query)
    DB.close()

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
deleteRows()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
show_all()
#+END_SRC

#+RESULTS:
: (1, 'Bill Borzo                         ', 0, 0)
: (2, 'Jeff Jeffries                      ', 0, 0)
: (3, 'Dave Davies                        ', 0, 0)
: (4, 'Steve Stevens                      ', 0, 0)

*** 2
#+BEGIN_SRC python :session *Python* :results output
showAllPLayers()
#+END_SRC

#+RESULTS:
: (1, 'Bill Borzo                         ', 0, 0)
: (2, 'Jeff Jeffries                      ', 0, 0)
: (3, 'Dave Davies                        ', 0, 0)
: (4, 'Steve Stevens                      ', 0, 0)

#+BEGIN_SRC python :session *Python* :results output
def deleteRows():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("delete from players1 where pid = 1;")
    c.execute("select * from players1;")
    c.fetchall()
    c.execute("delete from players1;")>
    c.execute("select * from players1;")
    c.fetchall()
    DB.commit()
    DB.close()

#+END_SRC

#+RESULTS:




#+RESULTS:

*** 3 finally work
#+BEGIN_SRC python :session *Python* :results output
def deleteRows():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("delete from players1;")
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
deleteRows()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
showAllPLayers()
#+END_SRC

#+RESULTS:

** work with a matches table

*** create table
#+BEGIN_SRC sql
create table players2(id serial PRIMARY KEY, player_name text not null, wins integer, matches integer);
#+END_SRC

#+BEGIN_SRC sql
-- create table matches2(winner text, loser text);
#+END_SRC
use ids (as integers) rather than strings
#+BEGIN_SRC sql
create table matches2(winner integer, loser integer);
#+END_SRC
create a backup copy
#+BEGIN_SRC sql
select * into matches_backup from matches;
#+END_SRC

#+END_SRC

*** addMatch

**** hard coded players
#+BEGIN_SRC python :session *Python* :results output
def addMatch():
    dbExecuteWrapper("""INSERT INTO matches2 VALUES ('Bill Borzo', 'Mike Michaels') ;""")
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :session *Python* :results output
addMatch()
#+END_SRC

#+RESULTS:

**** refactor
#+BEGIN_SRC python :session *Python* :results output
def addMatch(winner, loser):
    dbExecuteWrapper("""INSERT INTO matches2 VALUES (%s, %s) ;""", (winner, loser))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
addMatch('Bill Borzo', 'Dickshit')
#+END_SRC

#+RESULTS:

* use a wrapper for database execution code
refactor to take a 'table' as argument
** wrapper for write-only (no retrieval) SQL 'queries'
*** original
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
# def dbExecuteWrapper(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteWrapper("insert into players1 values(1, 'Bill Borzo', 0, 0); insert into players1 values(2, 'Jeff Jeffries', 0, 0); insert into players1 values(3, 'Dave Davies', 0, 0); insert into players1 values(4, 'Steve Stevens', 0, 0);")

#+END_SRC

#+RESULTS:
*** refactored versions
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
# def dbExecuteWrapper(query_string, extra=None):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

** wrapper when single-value retrieval is necessary
arggg--don't 'print' (thanks for only showing us print statements in
the video)
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
# def dbExecuteRetrievalWrapper(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    row = c.fetchone()
    print row
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteRetrievalWrapper("select count(*) from players1;")
#+END_SRC


#+RESULTS:
: (4L,)

#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
def dbExecuteRetrievalWrapper(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    row = c.fetchone()
    row_item = list(row)
    return int(row_item[0])
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteRetrievalWrapper("select count(*) from players1;")
#+END_SRC

#+RESULTS:
: 4

** wrapper when multi-entry retrieval is necessary

#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
def dbExecuteRetrievalWrapper_allrows(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    for row in rows:
        print row
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteRetrievalWrapper_allrows("select * from players1;")
#+END_SRC

#+RESULTS:
: (1, 'Bill Borzo                         ', 0, 0)
: (2, 'Jeff Jeffries                      ', 0, 0)
: (3, 'Dave Davies                        ', 0, 0)
: (4, 'Steve Stevens                      ', 0, 0)

* for staging
** wrappers
*** wrapper for write-only (no retrieval) SQL 'queries'
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
# def dbExecuteWrapper(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteWrapper("insert into players1 values(1, 'Bill Borzo', 0, 0); insert into players1 values(2, 'Jeff Jeffries', 0, 0); insert into players1 values(3, 'Dave Davies', 0, 0); insert into players1 values(4, 'Steve Stevens', 0, 0);")

#+END_SRC

#+RESULTS:
*** wrapper when single-value retrieval is necessary
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
def dbExecuteRetrievalWrapper(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    row = c.fetchone()
    print row
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteRetrievalWrapper("select count(*) from players1;")
#+END_SRC


#+RESULTS:
: (4L,)

*** wrapper when multi-entry retrieval is necessary

#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
def dbExecuteRetrievalWrapper_allrows(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    for row in rows:
        print row
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteRetrievalWrapper_allrows("select * from players1;")
#+END_SRC

#+RESULTS:
: (1, 'Bill Borzo                         ', 0, 0)
: (2, 'Jeff Jeffries                      ', 0, 0)
: (3, 'Dave Davies                        ', 0, 0)
: (4, 'Steve Stevens                      ', 0, 0)

*** refactored versions
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
def dbExecuteWrapper(query_string, extra=None):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
# def dbExecuteRetrievalWrapper(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    row = c.fetchone()

    DB.close()
#+END_SRC
** showAllPLayers--"select * from players1;"

*** hardcoding
#+BEGIN_SRC python :session *Python* :results output

def showAllPLayers():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    query = "select * from players2;"
    c.execute(query)
    rows = c.fetchall()
    # print rows
    for row in rows:
        print row

    DB.close()


#+END_SRC

#+RESULTS:



#+BEGIN_SRC python :session *Python* :results output
showAllPLayers()
#+END_SRC

#+RESULTS:
: (218, 'Fluttershy', 0, 1)
: (217, 'Twilight Sparkle', 1, 1)
: (220, 'Pinkie Pie', 0, 1)
: (219, 'Applejack', 1, 1)

*** refactor to use optional parameter
#+BEGIN_SRC python :session *Python* :results output

def showAllPLayers(table=players2):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    query = "select * from players1;"
    c.execute(query)
    rows = c.fetchall()
    # print rows
    for row in rows:
        print row
    DB.close()


#+END_SRC

#+RESULTS:
#+begin_example
'org_babel_python_eoe'
*** SyntaxError: unexpected EOF while parsing (<stdin>, line 1)
ipdb> >>> >>> Traceback (most recent call last):
  File "<ipython-input-99-ca2c63068dde>", line 1, in <module>
    c.execute(query)
NameError: name 'c' is not defined

> <ipython-input-99-ca2c63068dde>(1)<module>()
----> 1 c.execute(query)
*** NameError: name 'c' is not defined
*** SyntaxError: unexpected EOF while parsing (<stdin>, line 1)
*** SyntaxError: unexpected EOF while parsing (<stdin>, line 1)
*** NameError: name 'row' is not defined
#+end_example


** deleteRows--"delete from players1;"
#+BEGIN_SRC python :session *Python* :results output
def deleteRows():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("delete from players1;")
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
deleteRows()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
showAllPLayers()
#+END_SRC

#+RESULTS:
** countPlayers--"select count(*) from players1;"
*** better
writing a function like this without an explicit return value
(previously was relying on 'print'-ing out results) was producing
an error message that didn't make much sense to me (something about
tuple and int?)


#+BEGIN_SRC python :session *Python* :results output
def countPlayers():
    count = dbExecuteRetrievalWrapper("select count(*) from players1;")
    return count
#+END_SRC

#+RESULTS:
*** without using wrapper--returns integer!
#+BEGIN_SRC python :session *Python* :results output
def countPlayers():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("select count(*) from players1;")
    row = c.fetchone()
    row_item = list(row)
    return int(row_item[0])
    DB.close()
#+END_SRC

#+RESULTS:



#+RESULTS:
: 4

** registerPlayer(name)
*** try to understand this string substitution shit
#+BEGIN_SRC python :session *Python* :results output
def addPlayersDavidDavids():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("INSERT INTO players2 (player_name) VALUES (%s)" % "'David Davids'")
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
addPlayersDavidDavids()
#+END_SRC

#+RESULTS:



#+BEGIN_SRC python :session *Python* :results output
def addPlayers(name):
    # nim = str(name)
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("INSERT INTO players2 (player_name) VALUES (%s)" 
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
addPlayers('DickShit')
#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "<stdin>", line 5, in addPlayers
: psycopg2.ProgrammingError: column "name" does not exist
: LINE 1: INSERT INTO players2 (player_name) VALUES (name)
:                                                    ^





#+BEGIN_SRC python :session *Python* :results output
addPlayers("player_name")
#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "<stdin>", line 5, in addPlayers
: psycopg2.ProgrammingError: column "player_name" does not exist
: LINE 1: INSERT INTO players1 (player_name) VALUES (player_name)
:                                                    ^
: HINT:  There is a column named "player_name" in table "players1", but it cannot be referenced from this part of the query.

#+BEGIN_SRC python :session *Python* :results output
def addPlayersName():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("INSERT INTO players1 (player_name) VALUES (%s)" % (,))
    DB.commit()
    DB.close()
#+END_SRC
*** preferred PSQL parameter passing
#+BEGIN_SRC python :session *Python* :results output
cur.execute(
    """INSERT INTO some_table (an_int, a_date, a_string)
        VALUES (%s, %s, %s);""",
     (10, datetime.date(2005, 11, 18), "O'Reilly"))
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
c.execute("""INSERT INTO players2 (player_name, wins, matches) VALUES (%s, %s, %s);""", ("Will Williams", 0, 0))
#+END_SRC



#+RESULTS:
#+BEGIN_SRC python :session *Python* :results output
addWillName()
#+END_SRC

#+RESULTS:
*** final
#+BEGIN_SRC python :session *Python* :results output
#def registerPlayer(name):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("""INSERT INTO players2 (player_name, wins, matches) VALUES (%s, %s, %s);""", (name, 0, 0))
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
addPlayerName("Steve Stevens")
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Steven Stevens")
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
dbExecuteWrapper("insert into players1 values(1, 'Bill Borzo', 0, 0); insert into players1 values(2, 'Jeff Jeffries', 0, 0); insert into players1 values(3, 'Dave Davies', 0, 0); insert into players1 values(4, 'Steve Stevens', 0, 0);")

#+END_SRC
#+RESULTS:
*** refactor to use wrapper
should also be passing a table as a parameter?
#+BEGIN_SRC python :session *Python* :results output
def registerPlayer(name):
    dbExecuteWrapper("""INSERT INTO players2 (player_name, wins, matches) VALUES (%s, %s, %s);""", (name, 0, 0))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("May Mays")
#+END_SRC

#+RESULTS:

** playerStandings
*** description
#+BEGIN_SRC python :session *Python* :results output
"Returns a list of the players and their win records, sorted by wins. "
#+END_SRC
*** joins on players and matches
**** current tables in the database
select * from matches2;
select * from players2;
**** how to register win and matches column from matches?
- practice with a select to get the right column and query parameters
- turn the select into an update to change the value of the 'won' column
- ultimately, move the process into a single Python function
**** joining tables
table1
        join on 'shared column values' -- restriction clause -- count aggregation
table2
**** naive attempts
#+BEGIN_SRC sql
select players2.wins from matches2 join  players2 on matches2.winner = players2.player_name;
#+END_SRC
#+BEGIN_SRC sql
update players2 set wins = wins + 1  from players2  join matches2 on matches2.winner = players2.player_name;
#+END_SRC
#+BEGIN_SRC sql
update players2 set wins = wins + 1  from matches2 where players2.player_name = matches2.winner;
#+END_SRC
**** official postgres versions
http://www.postgresql.org/docs/9.1/static/sql-update.html

http://stackoverflow.com/questions/982919/sql-update-query-using-joins
#+BEGIN_SRC sql
UPDATE table1
SET    COLUMN = value
FROM   table2,
       table3
WHERE  table1.column_id = table2.id
       AND table1.column_id = table3.id
       AND table1.COLUMN = value
       AND table2.COLUMN = value
       AND table3.COLUMN = value 
#+END_SRC

#+BEGIN_SRC sql
update ud 
  set assid = (
               select sale.assid 
                 from sale 
                where sale.udid = ud.id
              )
 where exists (
               select * 
                 from sale 
                where sale.udid = ud.id
              );
#+END_SRC
*** update with a join--move to 'reportMatch'
#+BEGIN_SRC sql
update players2 set wins = wins + 1  from matches2 where players2.player_name = matches2.winner;
#+END_SRC
*** simple sql
#+BEGIN_SRC sql
select player_name, wins from players2 order by wins desc
#+END_SRC
*** definition
#+BEGIN_SRC python :session *Python* :results output
def playerStandings():
    dbExecuteRetrievalWrapper_allrows("""select player_name, wins from players2 order by wins desc;""")
#+END_SRC

#+RESULTS:

*** example of use
#+BEGIN_SRC python :session *Python* :results output
playerStandings()
#+END_SRC
#+RESULTS:
: ('May Mays', 0)
: ('Bill Borzo', 0)
: ('Steve Stevens', 0)
: ('Dick Shapiro', 0)

** reportMatch(winner, loser)
*** hardcoded table 'matches2'
#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    dbExecuteWrapper("""INSERT INTO matches2 VALUES (%s, %s) ;""", (winner, loser))
#+END_SRC

#+RESULTS:
*** refactoring
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
# def dbExecuteWrapper(query_string, extra=None):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
def dbExecuteWrapper_noparameter(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    dbExecuteWrapper("""INSERT INTO matches2 VALUES (%s, %s) ;""", (winner, loser))
    dbExecuteWrapper_noparameter("""update players2 set wins = wins + 1  from matches2 where players2.player_name = matches2.winner;""")
    dbExecuteWrapper_noparameter("""update players2 set matches = matches + 1  from matches2 where players2.player_name = matches2.winner OR players2.player_name = matches2.loser;""")

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch('Bill Borzo', 'David Davids')
#+END_SRC

#+RESULTS:

*** refactor to use an optional parameter for table
#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser, table=None):
    dbExecuteWrapper("""INSERT INTO %s VALUES (%s, %s) ;""", (table, winner, loser))
    dbExecuteWrapper("""update players2 set wins = wins + 1  from matches2 where players2.player_name = matches2.winner;""")
    dbExecuteWrapper("""update players2 set matches = matches + 1  from matches2 where players2.player_name = matches2.winner OR player2.player_name = matches2.loser;""")

#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql
update players2 set wins = wins + 1  from matches2 where players2.player_name = matches2.winner;
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
reportMatch('Bill Borzo', 'David Davids', table=matches2)
#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: NameError: name 'matches2' is not defined

** swissPairings

*** description
#+BEGIN_SRC python :session *Python* :results output
"Returns a list of pairs of players for the next round of a match"
#+END_SRC

* required functions for final--need refactoring
** use the provided connect() to do all the connecting
** import psycopg2 before testing
** all preferred wrapper functions
*** wrapper for plain updates, no retrieval
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# use this when no need to display anything
def dbExecuteWrapper(query_string, extra=None):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:
*** wrapper to retrieve all rows
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# use this when no need to display anything
def dbExecuteRetrievalWrapper_allrows(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    return rows
    DB.close()
#+END_SRC
*** wrapper for plain updates--do not use a parameter (why?)
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# use this when no need to display anything
def dbExecuteWrapper_noparameter(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

** deleteMatches
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def deleteMatches():
    dbExecuteWrapper("""delete from matches2;""")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql
delete from matches2;
#+END_SRC

** deletePlayers
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def deletePlayers():
    dbExecuteWrapper("""delete from players2;""")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql
delete from players2;
#+END_SRC

** countPlayers--players1 hardcoded
*** function definition--problems with dbExecuteRetrievalWrapper
#+BEGIN_SRC python :session *Python* :results output
# def countPlayers():
    count = dbExecuteRetrievalWrapper("select count(*) from players1;")
    return count
#+END_SRC

#+RESULTS:
*** no dbExecuteRetrievalWrapper--do not PRINT
refactor to use new improved dbExecuteRetrievalWrapper
#+BEGIN_SRC python :session *Python* :results output :tangle
def countPlayers():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("select count(*) from players2;")
    row = c.fetchone()
    row_item = list(row)
    return int(row_item[0])
    DB.close()
#+END_SRC

#+RESULTS:

*** example of use
#+BEGIN_SRC python :session *Python* :results output
countPlayers()
#+END_SRC

#+RESULTS:
: 0

** registerPlayer(name)
*** basic function
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def registerPlayer(name):
    dbExecuteWrapper("""INSERT INTO players2 (player_name, wins, matches) VALUES (%s, %s, %s);""", (name, 0, 0))
#+END_SRC

#+RESULTS:

*** examples of use
#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Bill Borzo")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("May Mays")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Steve Stevens")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Dick Shapiro")
#+END_SRC

#+RESULTS:

** playerStandings
*** improve 'allrows' usage
#+BEGIN_SRC python :session *Python* :results output
# use this when no need to display anything
def dbExecuteRetrievalWrapper_allrows(query_string):
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    return rows
    DB.close()
#+END_SRC

#+RESULTS:
*** refactor--do not use "allrows"
#+BEGIN_SRC python :session *Python* :results output
def playerStandings():
    DB = psycopg2.connect("dbname=tourney_practice")
    c = DB.cursor()
    c.execute("""select player_name, wins from players2 order by wins desc;""")
    dese_rows = c.fetchall()
    print type(dese_rows), len(dese_rows)
    return dese_rows
    DB.close()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def playerStandings():
    return dbExecuteRetrievalWrapper_allrows("""select id, player_name, wins, matches from players2 order by wins desc;""")
#+END_SRC
#+RESULTS:

*** example of use
#+BEGIN_SRC python :session *Python* :results output
playerStandings()
#+END_SRC
#+RESULTS:
: [(2, 'Bill Borzo', 0, 0), (3, 'May Mays', 0, 0), (4, 'Melpomene Murray', 0, 0), (5, 'Randy Schwartz', 0, 0)]

** reportMatch(winner, loser)
*** basic function

#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    dbExecuteWrapper("""INSERT INTO matches2 VALUES (%s, %s) ;""", (winner, loser))
    dbExecuteWrapper_noparameter("""update players2 set wins = wins + 1  from matches2 where players2.player_name = matches2.winner;""")
    dbExecuteWrapper_noparameter("""update players2 set matches = matches + 1  from matches2 where players2.player_name = matches2.winner OR players2.player_name = matches2.loser;""")

#+END_SRC

User player ids instead of names
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def reportMatch(winner, loser):
    dbExecuteWrapper("""INSERT INTO matches2 VALUES (%s, %s) ;""", (winner, loser))
    dbExecuteWrapper_noparameter("""update players2 set wins = wins + 1  from matches2 where players2.id = matches2.winner;""")
    dbExecuteWrapper_noparameter("""update players2 set matches = matches + 1  from matches2 where players2.id = matches2.winner OR players2.id = matches2.loser;""")

#+END_SRC
#+RESULTS:

*** examples of use--populate the table
#+BEGIN_SRC python :session *Python* :results output
reportMatch('Bill Borzo', 'Dick Shapiro')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch('Bill Borzo', 'May Mays')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch('Bill Borzo', 'Steve Stevens')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch('Steve Stevens', 'Dick Shapiro')
#+END_SRC

#+RESULTS:

*** bug in reportMatch?
Use 'set' in this way means that each time a match gets report, the
appearance of a previous match in the table gets counted and means
that certain players match count is inflated.

That is, reportMatch(id1, id2) performs correctly, but then following
it with reportMatch(id3, id4) gives another match and win to id1 and
id2. This is because the update statements are executed across the
full table again. 

Instead, they need to be called using the winner/loser parameters
only. I created this bug partly because I was not getting the behavior
I wanted when calling dbExecuteWrapper, specifically without a
parameter, which in fact was an error of logic on my part to begin
with.

Fix it. The where clause should specify the actual winners/losers
reported in this function call.

*** problematic sql code
#+BEGIN_SRC sql
where players2.id = matches2.winner
where players2.id = matches2.winner OR players2.id = matches2.loser
#+END_SRC

*** python fixes
#+BEGIN_SRC python :session *Python* :results output
    dbExecuteWrapper("""update players2 set wins = wins + 1  
from matches2 
where players2.id = (%s) ;""", (winner,))
#+END_SRC
#+BEGIN_SRC python :session *Python* :results output
    dbExecuteWrapper("""update players2 set matches = matches + 1  
from matches2 
where players2.id = (%s)
OR players2.id = (%s);""", (loser,))
#+END_SRC

*** update reportMatch
#+BEGIN_SRC python :session *Python* :results output
    dbExecuteWrapper("""update players2 set wins = wins + 1 from matches2 where players2.id = (%s) ;""", (winner,))
#+END_SRC
#+BEGIN_SRC python :session *Python* :results output

#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    dbExecuteWrapper("""INSERT INTO matches2 VALUES (%s, %s) ;""", (winner, loser))
    dbExecuteWrapper("""update players2 set wins = wins + 1 from matches2 where players2.id = (%s) ;""", (winner,))
    dbExecuteWrapper("""update players2 set matches = matches + 1  from matches2 where players2.id = (%s) OR players2.id = (%s);""", (winner, loser))
#+END_SRC

#+RESULTS:

** swissPairings

*** first naive go--returns many duplicates
#+BEGIN_SRC sql
select a.player_name, b.player_name from players2 as a, players2 as b where a.wins = b.wins
#+END_SRC

#+BEGIN_SRC sql
select a.player_name, b.player_name
from players2 as a, players2 as b
where a.wins = b.wins
and a.player_name != b.player_name

#+END_SRC

#+BEGIN_SRC sql
select a.player_name, b.player_name
from players2 as a, players2 as b
where a.wins = b.wins
and a.player_name != b.player_name
and a.id < b.id

#+END_SRC

*** one line for easier entering in cli--players2 vs. players
**** omitting the last a.id < b.id clause returns two matches for same pairing
#+BEGIN_SRC sql
select a.player_name, b.player_name from players2 as a, players2 as b where a.wins = b.wins and a.player_name != b.player_name
#+END_SRC

   player_name    |   player_name
------------------+------------------
 Twilight Sparkle | Applejack
 Fluttershy       | Pinkie Pie
 Applejack        | Twilight Sparkle
 Pinkie Pie       | Fluttershy

#+BEGIN_SRC sql
select a.player_name, b.player_name from players as a, players as b where a.wins = b.wins and a.player_name != b.player_name and a.id < b.id
#+END_SRC

*** add to python
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def swissPairings():
    return dbExecuteRetrievalWrapper_allrows("select a.id, a.player_name, b.id, b.player_name from players2 as a, players2 as b where a.wins = b.wins and a.player_name != b.player_name and a.id < b.id")

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
swissPairings()
#+END_SRC

#+RESULTS:
: [("Boots O'Neal", 'Diane Grant')]

#+BEGIN_SRC sql
select a.player_name, b.player_name from players2 as a, players2 as b where a.wins = b.wins and a.player_name != b.player_name and a.id < b.id
#+END_SRC
query needs player ids as well
#+BEGIN_SRC sql
select a.id, a.player_name, b.id, b.player_name from players2 as a, players2 as b where a.wins = b.wins and a.player_name != b.player_name and a.id < b.id
#+END_SRC
* run a series of SQL statement creating data
** test lines for testReportMatches
#+BEGIN_SRC python :session *Python* :results output
deleteMatches()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
deletePlayers()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
countPlayers()
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC python :session *Python* :results output
playerStandings()
#+END_SRC

#+RESULTS:
: []

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Twilight Sparkle")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Fluttershy")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Applejack")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Pinkie Pie")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
c = countPlayers()
print c
#+END_SRC

#+RESULTS:
: 
: 4



#+BEGIN_SRC python :session *Python* :results output
standings = playerStandings()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
[id1, id2, id3, id4] = [row[0] for row in standings]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
standings
#+END_SRC

#+RESULTS:
: [(45, 'Twilight Sparkle', 1, 1), (47, 'Applejack', 1, 1), (46, 'Fluttershy', 0, 1), (48, 'Pinkie Pie', 0, 1)]

#+BEGIN_SRC python :session *Python* :results output
reportMatch(id1, id2)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch(id3, id4)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
standings
#+END_SRC

#+RESULTS:
: [(37, 'Twilight Sparkle', 0, 0), (38, 'Fluttershy', 0, 0), (39, 'Applejack', 0, 0), (40, 'Pinkie Pie', 0, 0)]

#+BEGIN_SRC python :session *Python* :results output
pairings = swissPairings()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
len(pairings) != 2
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC python :session *Python* :results output
[(pid1, pname1, pid2, pname2), (pid3, pname3, pid4, pname4)] = pairings

#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: ValueError: need more than 1 value to unpack

#+BEGIN_SRC python :session *Python* :results output
correct_pairs = set([frozenset([id1, id3]), frozenset([id2, id4])])
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
actual_pairs = set([frozenset([pid1, pid2]), frozenset([pid3, pid4])])
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
correct_pairs != actual_pairs
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
#registerPlayer("Chandra Nalaar")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
#[(id1, name1, wins1, matches1), (id2, name2, wins2, matches2)] = standings
#+END_SRC
** test sequence for testPairings
#+BEGIN_SRC python :session *Python* :results output
deleteMatches()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
deletePlayers()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Twilight Sparkle")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Fluttershy")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Applejack")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Pinkie Pie")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
standings = playerStandings()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
[id1, id2, id3, id4] = [row[0] for row in standings]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch(id1, id2)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch(id3, id4)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
pairings = swissPairings()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
len(pairings) != 2
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC python :session *Python* :results output
[(pid1, pname1, pid2, pname2), (pid3, pname3, pid4, pname4)] = pairings
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
correct_pairs = set([frozenset([id1, id3]), frozenset([id2, id4])])
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
actual_pairs = set([frozenset([pid1, pid2]), frozenset([pid3, pid4])])
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
correct_pairs != actual_pairs
#+END_SRC


#+RESULTS:
: False

* typical SQL interactions
** create players1 table 
** drop players1 table
** insert a row
** add data to a row
** delete a row
** insert several rows
** count up rows
** DONE delete all rows
** DONE insert 4 rows
** create a new table for matches
* given project test code
** commented functions
#+BEGIN_SRC python :session *Python* :results output
import psycopg2
def deleteMatches():
    """Remove all the match records from the database."""
def deletePlayers():
    """Remove all the player records from the database."""
def countPlayers():
    """Returns the number of players currently registered."""
def registerPlayer(name):
    """Adds a player to the tournament database.
  
    The database assigns a unique serial id number for the player.  (This
    should be handled by your SQL database schema, not in your Python code.)
  
    Args:
      name: the player's full name (need not be unique).
    """
def playerStandings():
    """Returns a list of the players and their win records, sorted by wins.

    The first entry in the list should be the player in first place, or a player
    tied for first place if there is currently a tie.

    Returns:
      A list of tuples, each of which contains (id, name, wins, matches):
        id: the player's unique id (assigned by the database)
        name: the player's full name (as registered)
        wins: the number of matches the player has won
        matches: the number of matches the player has played
    """


def reportMatch(winner, loser):
    """Records the outcome of a single match between two players.

    Args:
      winner:  the id number of the player who won
      loser:  the id number of the player who lost
    """
 
 
def swissPairings():
    """Returns a list of pairs of players for the next round of a match.
  
    Assuming that there are an even number of players registered, each player
    appears exactly once in the pairings.  Each player is paired with another
    player with an equal or nearly-equal win record, that is, a player adjacent
    to him or her in the standings.
  
    Returns:
      A list of tuples, each of which contains (id1, name1, id2, name2)
        id1: the first player's unique id
        name1: the first player's name
        id2: the second player's unique id
        name2: the second player's name
    """

#+END_SRC
** blocks in org-babel
*** testReportMatches
**** reportMatches--contract
reportMatches takes two arguments, player ids as derived from
registering Players (registerPlayer) in the tournament and then popping them into a
standings with playerStandings
**** line by line code
#+BEGIN_SRC python :session *Python* :results output
deleteMatches()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
deletePlayers()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Bruno Walton")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Boots O'Neal")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Cathy Burton")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Diane Grant")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
standings = playerStandings()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
[id1, id2, id3, id4] = [row[0] for row in standings]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch(id1, id2)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
reportMatch(id3, id4)
#+END_SRC

#+RESULTS:

#+COMMENT for testing playerStandings
#+BEGIN_SRC python :session *Python* :results output
standings = playerStandings()
#+END_SRC

#+RESULTS:
#+END_SRC
*** testPairings
**** testPairings--contract
**** setup code shared with reportMatches
#+BEGIN_SRC python :session *Python* :results output
deleteMatches()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
deletePlayers()
#+END_SRC
**** use new unique names
#+BEGIN_SRC python :session *Python* :results output
registerPlayer("Twilight Sparkle")
registerPlayer("Fluttershy")
registerPlayer("Applejack")
registerPlayer("Pinkie Pie")
#+END_SRC
**** create some match results
#+BEGIN_SRC python :session *Python* :results output
standings = playerStandings()
[id1, id2, id3, id4] = [row[0] for row in standings]
reportMatch(id1, id2)
reportMatch(id3, id4)
#+END_SRC
**** unique to swissPairings test code
#+BEGIN_SRC python :session *Python* :results output
pairings = swissPairings()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
len(pairings) != 2
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC python :session *Python* :results output
[(pid1, pname1, pid2, pname2), (pid3, pname3, pid4, pname4)] = pairings
#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: ValueError: need more than 1 value to unpack

#+BEGIN_SRC python :session *Python* :results output
correct_pairs = set([frozenset([id1, id3]), frozenset([id2, id4])])
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
actual_pairs = set([frozenset([pid1, pid2]), frozenset([pid3, pid4])])
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
correct_pairs != actual_pairs
#+END_SRC
**** my swissPairings definition
#+BEGIN_SRC python :session *Python* :results output
def swissPairings():
    query = ("SELECT a.id, a.player_name, b.id, b.player_name "
             "FROM players as a, players as b "
             "WHERE a.wins = b.wins "
             "AND a.player_name != b.player_name "
             "AND a.id < b.id")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC

#+BEGIN_SRC python :session *Python* :results output

#+END_SRC
* extra credit features
** Prevent rematches between players.
*** natural planning
So basically, 

1. register some number of players greater than 4
   - work off an existing round number type of tournament
2. report an intial set of victories with reportMatches
   - plan how to set up the first batch of matches
     - 1 d. 2
     - 3 d. 4
     - etc.
3. tinker with swissPairings
   - add a clause that looks at entries in matches
4. use tourney_practice to experiment with the correct raw SQL 

|                    | "Twilight Sparkle" | "Fluttershy" | "Applejack" | "Pinkie Pie" | "Bruno Walton" | "Boots O'Neal" | "Cathy Burton" | "Diane Grant" |
|--------------------+--------------------+--------------+-------------+--------------+----------------+----------------+----------------+---------------|
| "Twilight Sparkle" | nil                |              |             |              |                |                |                |               |
| "Fluttershy"       |                    |              |             |              |                |                |                |               |
| "Applejack"        |                    |              |             |              |                |                |                |               |
| "Pinkie Pie"       |                    |              |             |              |                |                |                |               |
| "Bruno Walton"     |                    |              |             |              |                |                |                |               |
| "Boots O'Neal"     |                    |              |             |              |                |                |                |               |
| "Cathy Burton"     |                    |              |             |              |                |                |                |               |
| "Diane Grant"      |                    |              |             |              |                |                |                |               |
*** 4 abcd
| match no. | winner | loser |
|-----------+--------+-------|
|         1 | a      | b     |
|         2 | c      | d     |
|-----------+--------+-------|
|         3 | a      | c     |
|         4 | b      | d     |
|         5 |        |       |
|         6 |        |       |
|         7 |        |       |
|         8 |        |       |
|         9 |        |       |
|        10 |        |       |
|        11 |        |       |
|        12 |        |       |
|        13 |        |       |
|        14 |        |       |
|        15 |        |       |
|        16 |        |       |
*** 8 abcdefgh
| match no. | winner | loser | winner record | loser record |
|-----------+--------+-------+---------------+--------------|
|         1 | a      | b     |           0-0 |          0-0 |
|         2 | c      | d     |           0-0 |          0-0 |
|         3 | e      | f     |           0-0 |          0-0 |
|         4 | g      | h     |           0-0 |          0-0 |
|-----------+--------+-------+---------------+--------------|
|         5 | a      | c     |           1-0 |          1-0 |
|         6 | e      | g     |           1-0 |          1-0 |
|         7 | b      | d     |           0-1 |          0-1 |
|         8 | f      | h     |           0-1 |          0-1 |
|-----------+--------+-------+---------------+--------------|
|         9 | a      | e     |           2-0 |          2-0 |
|        10 | b      | c     |           1-1 |          1-1 |
|        11 | f      | g     |           1-1 |          1-1 |
|        12 | d      | h     |           0-2 |          0-2 |
|-----------+--------+-------+---------------+--------------|


| team | wins | losses | avg. wins of teams lost to |   |
|------+------+--------+----------------------------+---|
| a    |    3 |      0 |                          - |   |
| b    |    2 |      1 |                          3 |   |
| f    |    2 |      1 |                          1 |   |
| c    |    1 |      2 |                            |   |
| d    |    1 |      2 |                            |   |
| e    |    1 |      2 |                            |   |
| g    |    1 |      2 |                            |   |
| h    |    0 |      3 |                            |   |



*** number pairs to return!
    "For four players, swissPairings should return two pairs."
For eight players, what number of pairs to return?
Well, you'd need to report an initial group of 4 matches.

So, whereas the test for the meets specifications starts off so:

#+BEGIN_SRC python
registerPlayer("Twilight Sparkle")
    registerPlayer("Fluttershy")
    registerPlayer("Applejack")
    registerPlayer("Pinkie Pie")
    standings = playerStandings()
    [id1, id2, id3, id4] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
#+END_SRC

We would instead do something like

#+BEGIN_SRC python
registerPlayer("Twilight Sparkle")
registerPlayer("Fluttershy")
registerPlayer("Applejack")
registerPlayer("Pinkie Pie")

    registerPlayer("Bruno Walton")
    registerPlayer("Boots O'Neal")
    registerPlayer("Cathy Burton")
    registerPlayer("Diane Grant")

    standings = playerStandings()
    [id1, id2, id3, id4, id5, id6, id7, id8] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
    reportMatch(id5, id6)
    reportMatch(id7, id8)
#+END_SRC
*** 
*** 
** 
 Don’t assume an even number of players. If there is an odd number of
 players, assign one player a “bye” (skipped round). A bye counts as a
 free win. A player should not receive more than one bye in a
 tournament.
** 
 Support games where a draw (tied game) is possible. This will require
 changing the arguments to reportMatch.
** 
 When two players have the same number of wins, rank them according to
 OMW (Opponent Match Wins), the total number of wins by players they
 have played against.
** 
 Support more than one tournament in the database, so matches do not
 have to be deleted between tournaments. This will require
 distinguishing between “a registered player” and “a player who has
 entered in tournament #123”, so it will require changes to the
 database schema.
** 
 You may refer to outside resources to devise your pairing algorithm.
 Wizards of the Coast has prepared simple instructions, and more
 details can be found in resources linked to in the reference section
 of Wikipedia's article on Swiss tournaments.

