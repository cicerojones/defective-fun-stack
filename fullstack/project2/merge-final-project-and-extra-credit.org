* Python
  :PROPERTIES:
  :STATUS:   current
  :END:
** all Python definitions in one block
#+BEGIN_SRC python :session *Python* :results output :tangle yes
import psycopg2

def new_connect(dbname):
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)

def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()

def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()    
    return rows


def new_deleteTable(dbname, table_name):
    tb_name = table_name
    sql_keywords = """DELETE FROM """
    query = sql_keywords + tb_name
    table_nm = (table_name,)
    new_dbExecuteWrapper(query, dbname)

def new_countPlayers(dbname, table_name):
    DB = new_connect(dbname)
    c = DB.cursor()
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT count(*)" + from_statement + ";"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    DB.close()
    return int(row_item[0])


def insert_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """INSERT INTO """
    insert_statement = sql_keywords + tb_name

def update_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """UPDATE """
    update_statement = sql_keywords + tb_name

def keyword_statement_string(table_name, sql_keyword):
    tb_name = table_name
    sql_keywords = sql_keyword + """ """
    update_statement = sql_keywords + tb_name + """ """
    return update_statement

# refactor to allow substituting column names?
def new_registerPlayer(dbname, table_name, player_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name, wins, matchez)" + 
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, 0, 0))

# refactor to order by OMW for second column
def new_playerStandings(table_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = ("SELECT id, player_name, wins, matchez " +
             from_statement + "ORDER BY wins DESC;")
    return new_dbExecuteRetrievalWrapper_allrows("tourney_practice", query)


def new_reportMatch(dbname, table1, table2, winner, loser):
# why is table2 first in something named q1?
# q1 inserts into log of match events
# q2 is an updated that increment wins and match appearances

    q1_insert = keyword_statement_string(table2, """INSERT INTO""")
    q2_update = keyword_statement_string(table1, """UPDATE""")
    q2_from = keyword_statement_string(table2, """FROM""")
    query1 = (q1_insert + "VALUES (%s, %s) ;")
    query2 = (q2_update + "SET wins = wins + 1" + 
              q2_from + "WHERE playerz.id = (%s);")
    query3 = (q2_update + "SET matchez = matchez + 1" + 
              q2_from + "WHERE playerz.id = (%s) OR playerz.id = (%s);")
    new_dbExecuteWrapper(query1, dbname, (winner, loser))
    new_dbExecuteWrapper(query2, dbname, (winner,))
    new_dbExecuteWrapper(query3, dbname, (winner, loser))


def swissPairings():
    query = ("SELECT a.id, a.player_name, b.id, b.player_name "
             "FROM players as a, players as b "
             "WHERE a.wins = b.wins "
             "AND a.player_name != b.player_name "
             "AND a.id < b.id")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC

#+RESULTS:

** functions definitions by category
*** wrappers and utilities
**** db connection wrapper
#+BEGIN_SRC python :session *Python* :results output :tangle yes
import psycopg2

def new_connect(dbname):
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)
#+END_SRC

#+RESULTS:

**** cursor execute wrappers
     :PROPERTIES:
     :STAMPED:  [2016-03-30 Wed 11:02]
     :STATUS:   current
     :END:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()

def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()    
    return rows

# def insert_statement_string(table_name):
#     tb_name = table_name
#     sql_keywords = """INSERT INTO """
#     insert_statement = sql_keywords + tb_name

#+END_SRC

#+RESULTS:

**** SQL keyword string wrappers
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def update_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """UPDATE """
    update_statement = sql_keywords + tb_name

def keyword_statement_string(table_name, sql_keyword):
    tb_name = table_name
    sql_keywords = sql_keyword + """ """
    update_statement = sql_keywords + tb_name + """ """
    return update_statement
#+END_SRC

#+RESULTS:

*** simple delete and aggregate count
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_deleteTable(dbname, table_name):
    tb_name = table_name
    sql_keywords = """DELETE FROM """
    query = sql_keywords + tb_name
    table_nm = (table_name,)
    new_dbExecuteWrapper(query, dbname)

def new_countPlayers(dbname, table_name):
    DB = new_connect(dbname)
    c = DB.cursor()
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT count(*)" + from_statement + ";"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    DB.close()
    return int(row_item[0])
#+END_SRC

#+RESULTS:

*** registerPlayer, display playerStandings, reportMatch
**** registerPlayer
***** correct
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# refactor to allow substituting column names?
def new_registerPlayer(dbname, table_name, player_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name)" + 
             "VALUES (%s);")
    new_dbExecuteWrapper(query, dbname, (player_name,))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
new_registerPlayer("tourney_practice", "playerz", 'dddd');
#+END_SRC

#+RESULTS:
***** also-initialize player record
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# refactor to allow substituting column names?
def initialize_player_record(dbname, table_name, player_id):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_id)" + 
             "VALUES (%s);")
    new_dbExecuteWrapper(query, dbname, (player_id,))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
initialize_player_record("tourney_practice", "player_recordz", 1)
#+END_SRC

***** new--fix column names for tourney_practice db
      :PROPERTIES:
      :STATUS:   current
      :STAMPED:  [2016-03-30 Wed 11:02]
      :END:
Is the problem with how dbExecuteWrapper handles single argument inserts??
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC



#+BEGIN_SRC python :session *Python* :results output :tangle yes
# refactor to allow substituting column names?
def new_registerPlayer(dbname, table_name, player_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name)" + 
             "VALUES (%s);")
    new_dbExecuteWrapper(query, dbname, (player_name))
#+END_SRC


#+BEGIN_SRC python :session *Python* :results output :tangle yes
# don't forget your PARENS!!
def new_registerPlayer_tourney(player_name):
    query = """INSERT INTO playerz (player_name) VALUES (%s);"""
    new_dbExecuteWrapper(query, "tourney_practice", (player_name,))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
new_registerPlayer_tourney('cccc',);
#+END_SRC

#+RESULTS:

***** old
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# refactor to allow substituting column names?
def new_registerPlayer(dbname, table_name, player_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name, wins, matchez)" + 
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, 0, 0))
#+END_SRC

**** playerStandings
***** new--what are the columns we want? (assume points)
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def new_playerStandings(dbname, table_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = ("SELECT player_id, points " +
             from_statement + "ORDER BY points DESC;")
    return new_dbExecuteRetrievalWrapper_allrows(dbname, query)
#+END_SRC

#+RESULTS:



#+BEGIN_SRC python :session *Python* :results output :tangle yes
new_playerStandings("tourney_practice", "player_recordz")
#+END_SRC

#+RESULTS:
: []

**** reportMatch
***** old
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def new_reportMatch(dbname, table1, table2, winner, loser):
# why is table2 first in something named q1?
# q1 inserts into log of match events
# q2 is an updated that increment wins and match appearances

    q1_insert = keyword_statement_string(table2, """INSERT INTO""")
    q2_update = keyword_statement_string(table1, """UPDATE""")
    q2_from = keyword_statement_string(table2, """FROM""")
    query1 = (q1_insert + "VALUES (%s, %s) ;")
    query2 = (q2_update + "SET wins = wins + 1" + 
              q2_from + "WHERE playerz.id = (%s);")
    query3 = (q2_update + "SET matchez = matchez + 1" + 
              q2_from + "WHERE playerz.id = (%s) OR playerz.id = (%s);")
    new_dbExecuteWrapper(query1, dbname, (winner, loser))
    new_dbExecuteWrapper(query2, dbname, (winner,))
    new_dbExecuteWrapper(query3, dbname, (winner, loser))

#+END_SRC

***** must be completely rewritten
      :PROPERTIES:
      :STAMPED:  [2016-04-04 Mon 15:23]
      :END:
****** report Match was (winner, loser)
Before, there simply was a function that took a winner and loser (with
player ids).

It must be said that this makes for an extremely limited design.

#+BEGIN_SRC python :session *Python* :results output :tangle yes
"""INSERT INTO""" table {...match_participants...} """VALUES""" {...match_id, player_id1, player_id2...};
"""INSERT INTO""" table {...score_results...} """VALUES""" {...match_id, player1_score, player2_score...};
#+END_SRC


what happens when a match is reported now is:
****** registerMatch--correct
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- INSERT INTO matchez (match_id, tournament_name, round) VALUES (1, 'tennis', 1);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def registerMatch(dbname, table_name, match_no, tournament_name, round_of_tournament):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(match_id, tournament_name, round)" + 
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, tournament_name, round_of_tournament))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
registerMatch("tourney_practice", "matchez", 1, "soccer", 1);
#+END_SRC

#+RESULTS:

****** registerMatchParticipants--correct
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- INSERT INTO match_participants VALUES (1, 1, 2);
#+END_SRC

should it take a matchID argument? It does in the original SQL, but
perhaps it should just autoupdate? This really requires a function
that registers Matches (into the salient table) first.


#+BEGIN_SRC python :session *Python* :results output :tangle yes
def registerMatchParticipants(dbname, table_name, match_no, player_id1, player_id2):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, player_id1, player_id2))
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :session *Python* :results output :tangle yes
registerMatchParticipants("tourney_practice", "match_participants", 1, 1, 2)
#+END_SRC


#+RESULTS:

****** registerScores--correct
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- INSERT INTO score_results VALUES (1, 0, 1);
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def registerScores(dbname, table_name, match_no, home_score, away_score):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, home_score, away_score))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
registerScores("tourney_practice", "score_results", 1, 10, 10)
#+END_SRC

#+RESULTS:

****** log_player_records--must also use tournament_name?
   the round number
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT * FROM log_records(1);
#+END_SRC

#+RESULTS:
| log_records |
|-------------|
|             |

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_countPlayers(dbname, table_name):
    DB = new_connect(dbname)
    c = DB.cursor()
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT count(*)" + from_statement + ";"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    DB.close()
    return int(row_item[0])
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def log_player_simple(dbname, round_of_tournament):
    query = "SELECT * FROM log_records(%s)"
    new_dbExecuteWrapper(query, dbname, (round_of_tournament,))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
log_player_simple("tourney_practice", 1)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def log_player_records(round_of_tournament):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT *" + from_statement + "(%s)";
    new_dbExecuteWrapper(query, dbname, ())
#+END_SRC

****** call set_all_omw
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT * FROM set_all_OMW();
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def log_all_omw(dbname):
    query = "SELECT * FROM set_all_OMW();"
    new_dbExecuteWrapper(query, dbname)
#+END_SRC

#+RESULTS:

******* set_omw(player_id) for all player_ids
******** UPDATE player_recordz SET omw =
********* select sum(opponent_OMW) FROM player_omw(player_id)
*** swissPairings
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def swissPairings():
    query = ("SELECT a.id, a.player_name, b.id, b.player_name "
             "FROM players as a, players as b "
             "WHERE a.wins = b.wins "
             "AND a.player_name != b.player_name "
             "AND a.id < b.id")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC

** all Python functions grouped with examples
*** using examples for playerz and matchez
**** counting
 #+BEGIN_SRC python :session *Python* :results output :tangle yes
new_countPlayers("tourney_practice", "playerz")
 #+END_SRC

 #+RESULTS:
 : 2
**** deleting
***** Player records can be deleted
 #+BEGIN_SRC python :session *Python* :results output :tangle yes
new_deleteTable("tourney_practice", "playerz")
 #+END_SRC
***** old matches can be deleted
 #+BEGIN_SRC python :session *Python* :results output :tangle yes
new_deleteTable("tourney_practice", "matchez")
 #+END_SRC
***** 
*** examples that rely on hardcoded column names
**** registering players and initializing record
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# new_registerPlayer("tourney_practice", "playerz", 'dddd');
new_registerPlayer("tourney_practice", "playerz", 'eeee');
#+END_SRC

#+RESULTS:


#+begin_example
File "<ipython-input-24-4ead6ba9fd22>", line 5, in new_registerPlayer
    new_dbExecuteWrapper(query, dbname, (player_name, 0, 0))
  File "<ipython-input-16-80d9ed023749>", line 4, in new_dbExecuteWrapper
    c.execute(query_string, extra)
ProgrammingError: column "wins" of relation "playerz" does not exist
LINE 1: INSERT INTO playerz (player_name, wins, matchez)VALUES ('ddd...
                                          ^


> <ipython-input-16-80d9ed023749>(4)new_dbExecuteWrapper()
      3         c = DB.cursor()
----> 4         c.execute(query_string, extra)
      5         DB.commit()
#+end_example

#+BEGIN_SRC python :session *Python* :results output :tangle yes
initialize_player_record("tourney_practice", "player_recordz", 1)
#+END_SRC

#+RESULTS:

**** determining player standings
 #+BEGIN_SRC python :session *Python* :results output :tangle yes
new_playerStandings("playerz")
 #+END_SRC
**** reporting matching (inserting and updating)
 #+BEGIN_SRC python :session *Python* :results output :tangle yes
new_reportMatch("tourney_practice", 
 #+END_SRC
**** make pairings!!
** using sql and python for interactive repl practice
*** select all from tourney_practice database
**** playerz
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("SELECT * FROM playerz;")
cur.fetchall()
#+END_SRC

*** inserting with parameters--USE A FUCKING COMMA when it's ONE value!!!
**** insert player
     :PROPERTIES:
     :STAMPED:  [2016-04-04 Mon 10:41]
     :END:
***** insert player into playerz
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("bbbb",))
conn.commit()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output :tangle yes

#+END_SRC

***** insert more than one column value, unnecessarily
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("INSERT INTO playerz (player_id, player_name) VALUES (%s, %s)", (101, "dipshit"))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("INSERT INTO playerz (player_id, player_name) VALUES (%s, %s)", (103, "dipshits"))
conn.commit()
#+END_SRC

#+RESULTS:
***** try to insert one column value
****** doesn't work because of FUCKING lack of COMMA
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("dipshitz"))
conn.commit()
#+END_SRC

#+RESULTS:
: 
: >>> Traceback (most recent call last):
:   File "<ipython-input-175-1a4ec0045ab2>", line 1, in <module>
:     cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("dipshitz"))
: TypeError: not all arguments converted during string formatting
: 
: > <ipython-input-175-1a4ec0045ab2>(1)<module>()
: ----> 1 cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("dipshitz"))
****** /where/ do you put the comma?
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("dipshitz,"))
conn.commit()
#+END_SRC

#+RESULTS:
: 
: >>> Traceback (most recent call last):
:   File "<ipython-input-27-96fe9870e019>", line 1, in <module>
:     cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("dipshitz,"))
: TypeError: not all arguments converted during string formatting
: 
: > <ipython-input-27-96fe9870e019>(1)<module>()
: ----> 1 cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("dipshitz,"))
****** comma
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("INSERT INTO playerz (player_name) VALUES (%s)", ("dipshitz",))
conn.commit()
#+END_SRC

#+RESULTS:

***** create new table just for practicing inserting one column
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE fake_playerz (
       player_name text not null);
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|

#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("INSERT INTO fake_playerz VALUES (%s)", ("dipshitz",))
conn.commit()
#+END_SRC

#+RESULTS:

**** select players
#+BEGIN_SRC python :session *Python* :results output :tangle yes
conn = psycopg2.connect("dbname=tourney_practice")
cur = conn.cursor()
cur.execute("SELECT * FROM playerz;")
cur.fetchall()
#+END_SRC

#+RESULTS:
: 
: >>> >>> [(103, 'dipshits')]

** dealing with an open cursor
*** commit changes
# Make the changes to the database persistent
conn.commit()
#+END_SRC
*** close communication
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# Close communication with the database
cur.close()
conn.close()
#+END_SRC

#+RESULTS:

** work in development
** drafts of finished functions
*** definitions
#+BEGIN_SRC python :session *Python* :results output :tangle yes
import psycopg2

def new_connect(dbname):
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)

def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()

def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()    
    return rows

def update_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """UPDATE """
    update_statement = sql_keywords + tb_name

def keyword_statement_string(table_name, sql_keyword):
    tb_name = table_name
    sql_keywords = sql_keyword + """ """
    update_statement = sql_keywords + tb_name + """ """
    return update_statement

def new_deleteTable(dbname, table_name):
    tb_name = table_name
    sql_keywords = """DELETE FROM """
    query = sql_keywords + tb_name
    table_nm = (table_name,)
    new_dbExecuteWrapper(query, dbname)

def new_countPlayers(dbname, table_name):
    DB = new_connect(dbname)
    c = DB.cursor()
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT count(*)" + from_statement + ";"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    DB.close()
    return int(row_item[0])

# refactor to allow substituting column names?
def new_registerPlayer(dbname, table_name, player_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name)" + 
             "VALUES (%s);")
    new_dbExecuteWrapper(query, dbname, (player_name,))

# refactor to allow substituting column names?
def initialize_player_record(dbname, table_name, player_id):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_id)" + 
             "VALUES (%s);")
    new_dbExecuteWrapper(query, dbname, (player_id,))


def new_playerStandings(dbname, table_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = ("SELECT player_id, points " +
             from_statement + "ORDER BY points DESC;")
    return new_dbExecuteRetrievalWrapper_allrows(dbname, query)


def registerMatch(dbname, table_name, match_no, tournament_name, round_of_tournament):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(match_id, tournament_name, round)" + 
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, tournament_name, round_of_tournament))


def registerMatchParticipants(dbname, table_name, match_no, player_id1, player_id2):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, player_id1, player_id2))


def registerScores(dbname, table_name, match_no, home_score, away_score):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, home_score, away_score))

def log_player_simple(dbname, round_of_tournament):
    query = "SELECT * FROM log_records(%s)"
    new_dbExecuteWrapper(query, dbname, (round_of_tournament,))
#+END_SRC

*** examples
**** report-retrieve data
#+BEGIN_SRC python :session *Python* :results output :tangle yes
new_countPlayers("tourney_practice", "playerz")
#+END_SRC

#+RESULTS:
: 4

#+BEGIN_SRC python :session *Python* :results output :tangle yes
new_playerStandings("tourney_practice", "player_recordz")
#+END_SRC

#+RESULTS:
: [(3, 3), (1, 1), (2, 1), (4, 0)]

#+BEGIN_SRC python :session *Python* :results output :tangle yes
new_deleteTable("tourney_practice", "playerz")
#+END_SRC

**** insert data
#+BEGIN_SRC python :session *Python* :results output :tangle yes
new_registerPlayer("tourney_practice", "playerz", 'aaaa');
new_registerPlayer("tourney_practice", "playerz", 'bbbb');
new_registerPlayer("tourney_practice", "playerz", 'cccc');
new_registerPlayer("tourney_practice", "playerz", 'dddd');

initialize_player_record("tourney_practice", "player_recordz", 1)
initialize_player_record("tourney_practice", "player_recordz", 2)
initialize_player_record("tourney_practice", "player_recordz", 3)
initialize_player_record("tourney_practice", "player_recordz", 4)

registerMatch("tourney_practice", "matchez", 1, "soccer", 1);
registerMatch("tourney_practice", "matchez", 2, "soccer", 1);

registerMatchParticipants("tourney_practice", "match_participants", 1, 1, 2)
registerMatchParticipants("tourney_practice", "match_participants", 2, 3, 4)

registerScores("tourney_practice", "score_results", 1, 10, 10)
registerScores("tourney_practice", "score_results", 2, 11, 9)

log_player_simple("tourney_practice", 1)

log_all_omw("tourney_practice")
#+END_SRC

**** 
* SQL
  :LOGBOOK:
  CLOCK: [2016-04-04 Mon 15:33]
  :END:
** single blocks
*** all setups
**** 'tournament' database definition
#+BEGIN_SRC sql :engine postgresql :database tournament
-- CREATE DATABASE tournament;
-- \c tournament

CREATE TABLE players(id serial PRIMARY KEY, player_name text not null, wins integer, matches integer);

CREATE TABLE matches(winner integer, loser integer);

#+END_SRC
**** all 'tourney_practice' database CREATE definitions
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- only used for restarting with clean player ids
DROP TABLE playerz CASCADE; DROP TABLE matchez CASCADE; DROP TABLE match_participants; DROP TABLE score_results; DROP TABLE player_recordz;

-- matches have id number, a tournament name and a round number
CREATE TABLE matchez(
       match_id serial PRIMARY KEY,
       tournament_name text not null,
       round int); 

-- players have an id number and a name; 
-- theoretically can be in any tournaments? 
-- (need to distinguish btwn different results in different tournaments)
CREATE TABLE playerz (
       player_id serial PRIMARY KEY,
       player_name text not null);

-- matches have participants, arbitrarily assigned to home and away categories
CREATE TABLE match_participants(
       match_id int REFERENCES matchez (match_id),
       home int REFERENCES playerz (player_id),
       away int REFERENCES playerz (player_id));

-- results of matches have a score for the home and away players
CREATE TABLE score_results (
       match_id int REFERENCES matchez (match_id),
       home_score int,
       away_score int);

-- players have an amount of wins, losses and draws,
-- in cases where draws are possible, players also have points taking
-- this possibility into account.
-- finally, all players have an OMW score, which is the sum of the points
-- of those players they have faced
CREATE TABLE player_recordz (
       player_id int REFERENCES playerz (player_id),
       wins int DEFAULT 0,
       losses int DEFAULT 0,
       draws int DEFAULT 0,
       points int DEFAULT 0,
       OMW int DEFAULT 0);

-- a complete view of all tournaments shows any matches registered, 
-- as well as the scores in those matches
CREATE VIEW tournament_matches AS
select a.match_id, a.tournament_name, a.round, b.home, b.away, c.home_score, c.away_score
from matchez as a, match_participants as b, score_results as c
where a.match_id = b.match_id
AND b.match_id = c.match_id;

-- a complete view of a player shows the id/name as well as the various
-- statistics we take into account
CREATE VIEW player_tables AS
select a.player_id, a.player_name, b.wins, b.losses, b.draws, b.points, b.OMW
from playerz as a, player_recordz as b
where a.player_id = b.player_id;


-- to be able to reflect the results of matches in player stats, 
-- we need to distinguish the various kinds of wins, losses 
-- (and any draws if the tournament allows them)

-- the following update functions need to be called in the proper way 
-- and at the proper time (i.e. at the end of rounds of a particular tournament)
-- right now, there is the possibility of over-tabulating points if all matches 
-- for any particular rounds have not been registered yet
CREATE OR REPLACE FUNCTION log_draws(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET draws = draws + 1
       from tournament_matches as a 
       WHERE a.home_score = a.away_score
       AND (a.home = player_id OR a.away = player_id)
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_away_wins(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET wins = wins + 1
       from tournament_matches as a 
       WHERE a.home_score < a.away_score
       AND a.away = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_away_losses(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET losses = losses + 1
       from tournament_matches as a 
       WHERE a.home_score > a.away_score
       AND a.away = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_home_wins(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET wins = wins + 1
       from tournament_matches as a 
       WHERE a.home_score > a.away_score
       AND a.home = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_home_losses(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET losses = losses + 1
       from tournament_matches as a 
       WHERE a.home_score < a.away_score
       AND a.home = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

-- at the end of each round we want to tabulate the number of points for all participants
CREATE OR REPLACE FUNCTION update_points() RETURNS VOID AS $$
       UPDATE player_recordz 
       SET points = (wins * 3) + draws;
$$ LANGUAGE SQL;


-- we want to create tables collating all the opponents a given player has faced
CREATE OR REPLACE FUNCTION players_matches (integer) RETURNS TABLE (opposing_player int) AS $$
       select 
       	      CASE WHEN a.away = $1 THEN a.home
	      	   WHEN a.home = $1 THEN a.away
		   ELSE NULL
		END as opposing_player
FROM match_participants as a;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION player_OMW (integer) RETURNS TABLE (opponent int, opponent_OMW int) AS $$
       select opposing_player, a.points FROM players_matches($1) JOIN player_tables as A
       ON opposing_player = player_id
       WHERE opposing_player IS NOT NULL;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION set_omw (integer) RETURNS VOID AS $$
       UPDATE player_recordz SET omw = (select sum(opponent_OMW) FROM player_omw($1))
       WHERE player_id = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION set_all_OMW() RETURNS VOID AS $$
       select * from set_OMW(1);
       select * from set_OMW(2);
       select * from set_OMW(3);
       select * from set_OMW(4);
       select * from set_OMW(5);
       select * from set_OMW(6);
       select * from set_OMW(7);
       select * from set_OMW(8);
$$ LANGUAGE SQL;


-- uses a $name$ syntax erroneously?
CREATE OR REPLACE FUNCTION log_records(round integer) RETURNS VOID as $log_records$
       SELECT log_home_losses($1);
       SELECT log_home_wins($1);
       SELECT log_away_losses($1);
       SELECT log_away_wins($1);
       SELECT log_draws($1);
       SELECT update_points();
       $log_records$ LANGUAGE SQL;

#+END_SRC

#+RESULTS:
| DROP TABLE      |
|-----------------|
| DROP TABLE      |
| DROP TABLE      |
| DROP TABLE      |
| DROP TABLE      |
| CREATE TABLE    |
| CREATE TABLE    |
| CREATE TABLE    |
| CREATE TABLE    |
| CREATE TABLE    |
| CREATE VIEW     |
| CREATE VIEW     |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |
| CREATE FUNCTION |



**** all insert and update functions
#+BEGIN_SRC sql :engine postgresql :database tourney_practice

INSERT INTO matchez (match_id, tournament_name, round) VALUES (1, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (2, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (3, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (4, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (5, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (6, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (7, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (8, 'tennis', 2);

-- should inserting a player name into playerz trigger a player_id insert into player_recordz?

INSERT INTO playerz (player_name) VALUES ('a');
INSERT INTO playerz (player_name) VALUES ('b');
INSERT INTO playerz (player_name) VALUES ('c');
INSERT INTO playerz (player_name) VALUES ('d');
INSERT INTO playerz (player_name) VALUES ('e');
INSERT INTO playerz (player_name) VALUES ('f');
INSERT INTO playerz (player_name) VALUES ('g');
INSERT INTO playerz (player_name) VALUES ('h');

INSERT INTO player_recordz (player_id) VALUES (1);
-- INSERT INTO player_recordz (player_id) VALUES IN [1, 2];
INSERT INTO player_recordz (player_id) VALUES (2);
INSERT INTO player_recordz (player_id) VALUES (3);
INSERT INTO player_recordz (player_id) VALUES (4);
INSERT INTO player_recordz (player_id) VALUES (5);
INSERT INTO player_recordz (player_id) VALUES (6);
INSERT INTO player_recordz (player_id) VALUES (7);
INSERT INTO player_recordz (player_id) VALUES (8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
**** insert tournament rounds data
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO match_participants VALUES (1, 1, 2);
INSERT INTO match_participants VALUES (2, 3, 4);
INSERT INTO match_participants VALUES (3, 5, 6);
INSERT INTO match_participants VALUES (4, 7, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO score_results VALUES (1, 0, 1);
INSERT INTO score_results VALUES (2, 1, 0);
INSERT INTO score_results VALUES (3, 0, 1);
INSERT INTO score_results VALUES (4, 1, 0);
SELECT * FROM log_records(1);
SELECT * FROM set_all_OMW();
#+END_SRC

#+RESULTS:
| INSERT 0 1  |
|-------------|
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| log_records |
|             |
| set_all_omw |
|             |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice

INSERT INTO match_participants VALUES (5, 2, 3);
INSERT INTO match_participants VALUES (6, 6, 7);
INSERT INTO match_participants VALUES (7, 1, 4);
INSERT INTO match_participants VALUES (8, 5, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO score_results VALUES (5, 0, 10);
INSERT INTO score_results VALUES (6, 10, 0);
INSERT INTO score_results VALUES (7, 0, 10);
INSERT INTO score_results VALUES (8, 1, 10);
select * from log_records(2);
select * from set_all_omw();
#+END_SRC

#+RESULTS:
| INSERT 0 1  |
|-------------|
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| log_records |
|             |
| set_all_omw |
|             |
** tourney setup broken up by statement
*** all 'tourney_practice' database CREATE definitions
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- only used for restarting with clean player ids
DROP TABLE playerz CASCADE; DROP TABLE matchez CASCADE; DROP TABLE match_participants; DROP TABLE score_results; DROP TABLE player_recordz;
#+END_SRC

#+RESULTS:
| DROP TABLE |
|------------|
| DROP TABLE |
| DROP TABLE |
| DROP TABLE |
| DROP TABLE |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- matches have id number, a tournament name and a round number
CREATE TABLE matchez(
       match_id serial PRIMARY KEY,
       tournament_name text not null,
       round int); 

-- players have an id number and a name; 
-- theoretically can be in any tournaments? 
-- (need to distinguish btwn different results in different tournaments)
CREATE TABLE playerz (
       player_id serial PRIMARY KEY,
       player_name text not null);

-- matches have participants, arbitrarily assigned to home and away categories
CREATE TABLE match_participants(
       match_id int REFERENCES matchez (match_id),
       home int REFERENCES playerz (player_id),
       away int REFERENCES playerz (player_id));

-- results of matches have a score for the home and away players
CREATE TABLE score_results (
       match_id int REFERENCES matchez (match_id),
       home_score int,
       away_score int);

-- players have an amount of wins, losses and draws,
-- in cases where draws are possible, players also have points taking
-- this possibility into account.
-- finally, all players have an OMW score, which is the sum of the points
-- of those players they have faced
CREATE TABLE player_recordz (
       player_id int REFERENCES playerz (player_id),
       wins int DEFAULT 0,
       losses int DEFAULT 0,
       draws int DEFAULT 0,
       points int DEFAULT 0,
       OMW int DEFAULT 0);

-- a complete view of all tournaments shows any matches registered, 
-- as well as the scores in those matches
CREATE VIEW tournament_matches AS
select a.match_id, a.tournament_name, a.round, b.home, b.away, c.home_score, c.away_score
from matchez as a, match_participants as b, score_results as c
where a.match_id = b.match_id
AND b.match_id = c.match_id;

-- a complete view of a player shows the id/name as well as the various
-- statistics we take into account
CREATE VIEW player_tables AS
select a.player_id, a.player_name, b.wins, b.losses, b.draws, b.points, b.OMW
from playerz as a, player_recordz as b
where a.player_id = b.player_id;

#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE VIEW  |
| CREATE VIEW  |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- to be able to reflect the results of matches in player stats, 
-- we need to distinguish the various kinds of wins, losses 
-- (and any draws if the tournament allows them)

-- the following update functions need to be called in the proper way 
-- and at the proper time (i.e. at the end of rounds of a particular tournament)
-- right now, there is the possibility of over-tabulating points if all matches 
-- for any particular rounds have not been registered yet
CREATE OR REPLACE FUNCTION log_draws(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET draws = draws + 1
       from tournament_matches as a 
       WHERE a.home_score = a.away_score
       AND (a.home = player_id OR a.away = player_id)
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_away_wins(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET wins = wins + 1
       from tournament_matches as a 
       WHERE a.home_score < a.away_score
       AND a.away = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_away_losses(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET losses = losses + 1
       from tournament_matches as a 
       WHERE a.home_score > a.away_score
       AND a.away = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_home_wins(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET wins = wins + 1
       from tournament_matches as a 
       WHERE a.home_score > a.away_score
       AND a.home = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION log_home_losses(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET losses = losses + 1
       from tournament_matches as a 
       WHERE a.home_score < a.away_score
       AND a.home = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;

-- at the end of each round we want to tabulate the number of points for all participants
CREATE OR REPLACE FUNCTION update_points() RETURNS VOID AS $$
       UPDATE player_recordz 
       SET points = (wins * 3) + draws;
$$ LANGUAGE SQL;

#+END_SRC

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- we want to create tables collating all the opponents a given player has faced
CREATE OR REPLACE FUNCTION players_matches (integer) RETURNS TABLE (opposing_player int) AS $$
       select 
       	      CASE WHEN a.away = $1 THEN a.home
	      	   WHEN a.home = $1 THEN a.away
		   ELSE NULL
		END as opposing_player
FROM match_participants as a;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION player_OMW (integer) RETURNS TABLE (opponent int, opponent_OMW int) AS $$
       select opposing_player, a.points FROM players_matches($1) JOIN player_tables as A
       ON opposing_player = player_id
       WHERE opposing_player IS NOT NULL;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION set_omw (integer) RETURNS VOID AS $$
       UPDATE player_recordz SET omw = (select sum(opponent_OMW) FROM player_omw($1))
       WHERE player_id = $1;
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION set_all_OMW() RETURNS VOID AS $$
       select * from set_OMW(1);
       select * from set_OMW(2);
       select * from set_OMW(3);
       select * from set_OMW(4);
       select * from set_OMW(5);
       select * from set_OMW(6);
       select * from set_OMW(7);
       select * from set_OMW(8);
$$ LANGUAGE SQL;


-- uses a $name$ syntax erroneously?
CREATE OR REPLACE FUNCTION log_records(round integer) RETURNS VOID as $log_records$
       SELECT log_home_losses($1);
       SELECT log_home_wins($1);
       SELECT log_away_losses($1);
       SELECT log_away_wins($1);
       SELECT log_draws($1);
       SELECT update_points();
       $log_records$ LANGUAGE SQL;

#+END_SRC
*** tourney insert and update functions broken up by statement
#+BEGIN_SRC sql :engine postgresql :database tourney_practice

INSERT INTO matchez (match_id, tournament_name, round) VALUES (1, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (2, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (3, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (4, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (5, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (6, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (7, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (8, 'tennis', 2);

-- should inserting a player name into playerz trigger a player_id insert into player_recordz?
#+END_SRC

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name) VALUES ('a');
INSERT INTO playerz (player_name) VALUES ('b');
INSERT INTO playerz (player_name) VALUES ('c');
INSERT INTO playerz (player_name) VALUES ('d');
INSERT INTO playerz (player_name) VALUES ('e');
INSERT INTO playerz (player_name) VALUES ('f');
INSERT INTO playerz (player_name) VALUES ('g');
INSERT INTO playerz (player_name) VALUES ('h');

#+END_SRC

#+BEGIN_SRC sql :engine postgresql :database tourney_practice

INSERT INTO player_recordz (player_id) VALUES (1);
-- INSERT INTO player_recordz (player_id) VALUES IN [1, 2];
INSERT INTO player_recordz (player_id) VALUES (2);
INSERT INTO player_recordz (player_id) VALUES (3);
INSERT INTO player_recordz (player_id) VALUES (4);
INSERT INTO player_recordz (player_id) VALUES (5);
INSERT INTO player_recordz (player_id) VALUES (6);
INSERT INTO player_recordz (player_id) VALUES (7);
INSERT INTO player_recordz (player_id) VALUES (8);
#+END_SRC
*** insert tournament rounds data broken up by category
**** insert match participants (match id, home.id, away.id)
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO match_participants VALUES (1, 1, 2);
INSERT INTO match_participants VALUES (2, 3, 4);
INSERT INTO match_participants VALUES (3, 5, 6);
INSERT INTO match_participants VALUES (4, 7, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
**** insert score results (match id, home.score, away.score)
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO score_results VALUES (1, 0, 1);
INSERT INTO score_results VALUES (2, 1, 0);
INSERT INTO score_results VALUES (3, 0, 1);
INSERT INTO score_results VALUES (4, 1, 0);
#+END_SRC
**** log values into players records, setting their OMWs too
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT * FROM log_records(1);
SELECT * FROM set_all_OMW();
#+END_SRC

#+RESULTS:
| INSERT 0 1  |
|-------------|
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| log_records |
|             |
| set_all_omw |
|             |
**** repeat for round 2
#+BEGIN_SRC sql :engine postgresql :database tourney_practice

INSERT INTO match_participants VALUES (5, 2, 3);
INSERT INTO match_participants VALUES (6, 6, 7);
INSERT INTO match_participants VALUES (7, 1, 4);
INSERT INTO match_participants VALUES (8, 5, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
**** score results
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO score_results VALUES (5, 0, 10);
INSERT INTO score_results VALUES (6, 10, 0);
INSERT INTO score_results VALUES (7, 0, 10);
INSERT INTO score_results VALUES (8, 1, 10);
#+END_SRC
**** player data
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from log_records(2);
select * from set_all_omw();
#+END_SRC

#+RESULTS:
| INSERT 0 1  |
|-------------|
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| log_records |
|             |
| set_all_omw |
|             |
* display contents of tables and views
** plain tables
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from matchez;
select * from playerz;
select * from match_participants;
select * from score_results;
select * from player_recordz;
#+END_SRC


#+RESULTS:
|  match_id | tournament_name |      round |       |        |     |
|-----------+-----------------+------------+-------+--------+-----|
|         1 |          tennis |          1 |       |        |     |
|         2 |          tennis |          1 |       |        |     |
|         3 |          tennis |          1 |       |        |     |
|         4 |          tennis |          1 |       |        |     |
|         5 |          tennis |          2 |       |        |     |
|         6 |          tennis |          2 |       |        |     |
|         7 |          tennis |          2 |       |        |     |
|         8 |          tennis |          2 |       |        |     |
| player_id |     player_name |            |       |        |     |
|         1 |               a |            |       |        |     |
|         2 |               b |            |       |        |     |
|         3 |               c |            |       |        |     |
|         4 |               d |            |       |        |     |
|         5 |               e |            |       |        |     |
|         6 |               f |            |       |        |     |
|         7 |               g |            |       |        |     |
|         8 |               h |            |       |        |     |
|  match_id |            home |       away |       |        |     |
|         1 |               1 |          2 |       |        |     |
|         2 |               3 |          4 |       |        |     |
|         3 |               5 |          6 |       |        |     |
|         4 |               7 |          8 |       |        |     |
|         5 |               2 |          3 |       |        |     |
|         6 |               6 |          7 |       |        |     |
|         7 |               1 |          4 |       |        |     |
|         8 |               5 |          8 |       |        |     |
|  match_id |      home_score | away_score |       |        |     |
|         1 |               0 |          1 |       |        |     |
|         2 |               1 |          0 |       |        |     |
|         3 |               0 |          1 |       |        |     |
|         4 |               1 |          0 |       |        |     |
|         1 |               0 |          1 |       |        |     |
|         2 |               1 |          0 |       |        |     |
|         3 |               0 |          1 |       |        |     |
|         4 |               1 |          0 |       |        |     |
|         5 |               0 |         10 |       |        |     |
|         6 |              10 |          0 |       |        |     |
|         7 |               0 |         10 |       |        |     |
|         8 |               1 |         10 |       |        |     |
| player_id |            wins |     losses | draws | points | omw |
|         1 |               0 |          2 |     0 |      0 |   6 |
|         5 |               0 |          2 |     0 |      0 |   6 |
|         2 |               1 |          1 |     0 |      3 |   6 |
|         6 |               2 |          0 |     0 |      6 |   6 |
|         7 |               1 |          1 |     0 |      3 |   6 |
|         3 |               2 |          0 |     0 |      6 |   6 |
|         4 |               1 |          1 |     0 |      3 |   6 |
|         8 |               1 |          1 |     0 |      3 |   6 |

** two views
*** tournament_matches and player_recordz
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from tournament_matches;
#+END_SRC

#+RESULTS:
| match_id | tournament_name | round | home | away | home_score | away_score |
|----------+-----------------+-------+------+------+------------+------------|
|        1 | tennis          |     1 |    1 |    2 |          0 |          1 |
|        2 | tennis          |     1 |    3 |    4 |          1 |          0 |
|        3 | tennis          |     1 |    5 |    6 |          0 |          1 |
|        4 | tennis          |     1 |    7 |    8 |          1 |          0 |
|        5 | tennis          |     2 |    2 |    3 |          0 |         10 |
|        6 | tennis          |     2 |    6 |    7 |         10 |          0 |
|        7 | tennis          |     2 |    1 |    4 |          0 |         10 |
|        8 | tennis          |     2 |    5 |    8 |          1 |         10 |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from player_recordz;
#+END_SRC

#+RESULTS:
| player_id | wins | losses | draws | points | omw |
|-----------+------+--------+-------+--------+-----|
|         1 |    0 |      2 |     0 |      0 |   6 |
|         2 |    1 |      1 |     0 |      3 |   6 |
|         3 |    2 |      0 |     0 |      6 |   6 |
|         4 |    1 |      1 |     0 |      3 |   6 |
|         5 |    0 |      2 |     0 |      0 |   9 |
|         6 |    2 |      0 |     0 |      6 |   3 |
|         7 |    1 |      1 |     0 |      3 |   9 |
|         8 |    1 |      1 |     0 |      3 |   3 |
** player_tables
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from player_tables
ORDER BY player_id;
;
#+END_SRC

#+RESULTS:
| player_id | player_name | wins | losses | draws | points | omw |
|-----------+-------------+------+--------+-------+--------+-----|
|         1 | a           |    0 |      2 |     0 |      0 |   6 |
|         2 | b           |    1 |      1 |     0 |      3 |   6 |
|         3 | c           |    2 |      0 |     0 |      6 |   0 |
|         4 | d           |    1 |      1 |     0 |      3 |   0 |
|         5 | e           |    0 |      2 |     0 |      0 |   0 |
|         6 | f           |    2 |      0 |     0 |      6 |   0 |
|         7 | g           |    1 |      1 |     0 |      3 |   0 |
|         8 | h           |    1 |      1 |     0 |      3 |   0 |
** view provisional pairings
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT a.player_id, a.OMW, a.wins, a.losses, a.draws, b.player_id, b.OMW, b.wins, b.losses, b.draws

FROM player_recordz as a, player_recordz as b

WHERE a.wins = b.wins AND a.losses = b.losses 

AND a.player_id < b.player_id

ORDER BY a.wins DESC, a.omw DESC;
#+END_SRC  

#+RESULTS:
| player_id | omw | wins | losses | draws | player_id | omw | wins | losses | draws |
|-----------+-----+------+--------+-------+-----------+-----+------+--------+-------|
|         3 |   6 |    2 |      0 |     0 |         6 |   3 |    2 |      0 |     0 |
|         7 |   9 |    1 |      1 |     0 |         8 |   3 |    1 |      1 |     0 |
|         2 |   6 |    1 |      1 |     0 |         7 |   9 |    1 |      1 |     0 |
|         2 |   6 |    1 |      1 |     0 |         4 |   6 |    1 |      1 |     0 |
|         2 |   6 |    1 |      1 |     0 |         8 |   3 |    1 |      1 |     0 |
|         4 |   6 |    1 |      1 |     0 |         8 |   3 |    1 |      1 |     0 |
|         4 |   6 |    1 |      1 |     0 |         7 |   9 |    1 |      1 |     0 |
|         1 |   6 |    0 |      2 |     0 |         5 |   9 |    0 |      2 |     0 |

