* original
** one block
#+BEGIN_SRC python :session *Python* :results output :tangle yes
#!/usr/bin/env python
#
# Test cases for tournament.py

from final_project import *

def testDeleteMatches():
    deleteMatches()
    print "1. Old matches can be deleted."


def testDelete():
    deleteMatches()
    deletePlayers()
    print "2. Player records can be deleted."


def testCount():
    deleteMatches()
    deletePlayers()
    c = countPlayers()
    if c == '0':
        raise TypeError(
            "countPlayers() should return numeric zero, not string '0'.")
    if c != 0:
        raise ValueError("After deleting, countPlayers should return zero.")
    print "3. After deleting, countPlayers() returns zero."


def testRegister():
    deleteMatches()
    deletePlayers()
    registerPlayer("Chandra Nalaar")
    c = countPlayers()
    if c != 1:
        raise ValueError(
            "After one player registers, countPlayers() should be 1.")
    print "4. After registering a player, countPlayers() returns 1."


def testRegisterCountDelete():
    deleteMatches()
    deletePlayers()
    registerPlayer("Markov Chaney")
    registerPlayer("Joe Malik")
    registerPlayer("Mao Tsu-hsi")
    registerPlayer("Atlanta Hope")
    c = countPlayers()
    if c != 4:
        raise ValueError(
            "After registering four players, countPlayers should be 4.")
    deletePlayers()
    c = countPlayers()
    if c != 0:
        raise ValueError("After deleting, countPlayers should return zero.")
    print "5. Players can be registered and deleted."


def testStandingsBeforeMatches():
    deleteMatches()
    deletePlayers()
    registerPlayer("Melpomene Murray")
    registerPlayer("Randy Schwartz")
    standings = playerStandings()
    if len(standings) < 2:
        raise ValueError("Players should appear in playerStandings even before "
                         "they have played any matches.")
    elif len(standings) > 2:
        raise ValueError("Only registered players should appear in standings.")
    if len(standings[0]) != 4:
        raise ValueError("Each playerStandings row should have four columns.")
    [(id1, name1, wins1, matches1), (id2, name2, wins2, matches2)] = standings
    if matches1 != 0 or matches2 != 0 or wins1 != 0 or wins2 != 0:
        raise ValueError(
            "Newly registered players should have no matches or wins.")
    if set([name1, name2]) != set(["Melpomene Murray", "Randy Schwartz"]):
        raise ValueError("Registered players' names should appear in standings, "
                         "even if they have no matches played.")
    print "6. Newly registered players appear in the standings with no matches."


def testReportMatches():
    deleteMatches()
    deletePlayers()
    registerPlayer("Bruno Walton")
    registerPlayer("Boots O'Neal")
    registerPlayer("Cathy Burton")
    registerPlayer("Diane Grant")
    standings = playerStandings()
    [id1, id2, id3, id4] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
    standings = playerStandings()
    for (i, n, w, m) in standings:
        if m != 1:
            raise ValueError("Each player should have one match recorded.")
        if i in (id1, id3) and w != 1:
            raise ValueError("Each match winner should have one win recorded.")
        elif i in (id2, id4) and w != 0:
            raise ValueError("Each match loser should have zero wins recorded.")
    print "7. After a match, players have updated standings."


def testPairings():
    deleteMatches()
    deletePlayers()
    registerPlayer("Twilight Sparkle")
    registerPlayer("Fluttershy")
    registerPlayer("Applejack")
    registerPlayer("Pinkie Pie")
    standings = playerStandings()
    [id1, id2, id3, id4] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
    pairings = swissPairings()
    if len(pairings) != 2:
        raise ValueError(
            "For four players, swissPairings should return two pairs.")
    [(pid1, pname1, pid2, pname2), (pid3, pname3, pid4, pname4)] = pairings
    correct_pairs = set([frozenset([id1, id3]), frozenset([id2, id4])])
    actual_pairs = set([frozenset([pid1, pid2]), frozenset([pid3, pid4])])
    if correct_pairs != actual_pairs:
        raise ValueError(
            "After one match, players with one win should be paired.")
    print "8. After one match, players with one win are paired."


if __name__ == '__main__':
    testDeleteMatches()
    testDelete()
    testCount()
    testRegister()
    testRegisterCountDelete()
    testStandingsBeforeMatches()
    testReportMatches()
    testPairings()
    print "Success!  All tests pass!"



#+END_SRC
* exceeds-sequence
** whole sequence of two tournaments in one block (fails as a babel block)
#+BEGIN_SRC python :session *Python* :results output :tangle yes


new_registerPlayer("tourney_practice", "playerz", 'a', "tennis")
new_registerPlayer("tourney_practice", "playerz", 'b', "tennis")
new_registerPlayer("tourney_practice", "playerz", 'c', "tennis")
new_registerPlayer("tourney_practice", "playerz", 'd', "tennis")
new_registerPlayer("tourney_practice", "playerz", 'e', "tennis")
new_registerPlayer("tourney_practice", "playerz", 'f', "tennis")
new_registerPlayer("tourney_practice", "playerz", 'g', "tennis")
new_registerPlayer("tourney_practice", "playerz", 'h', "tennis")

registerMatchParticipants("tourney_practice", "match_participants", "tennis", 1, 1, 2)
registerMatchParticipants("tourney_practice", "match_participants", "tennis", 1, 3, 4)
registerMatchParticipants("tourney_practice", "match_participants", "tennis", 1, 5, 6)
registerMatchParticipants("tourney_practice", "match_participants", "tennis", 1, 7, 8)

registerScores("tourney_practice", "score_results", 1, 1, 0)
registerScores("tourney_practice", "score_results", 2, 0, 1)
registerScores("tourney_practice", "score_results", 3, 1, 0)
registerScores("tourney_practice", "score_results", 4, 0, 1)

log_round_results("tourney_practice", "tennis", 1)
set_all_OMW('tourney_practice')

naive_swissPairings(2, "tennis")

registerScores("tourney_practice", "score_results", 5, 1, 0)
registerScores("tourney_practice", "score_results", 6, 0, 1)
registerScores("tourney_practice", "score_results", 7, 1, 0)
registerScores("tourney_practice", "score_results", 8, 0, 1)

log_round_results("tourney_practice", "tennis", 2)
set_all_OMW('tourney_practice')

naive_swissPairings(3, "tennis")

registerScores("tourney_practice", "score_results", 9, 1, 0)
registerScores("tourney_practice", "score_results", 10, 0, 1)
registerScores("tourney_practice", "score_results", 11, 1, 0)
registerScores("tourney_practice", "score_results", 12, 0, 1)

log_round_results("tourney_practice", "tennis", 3)
set_all_OMW('tourney_practice')

new_registerPlayer("tourney_practice", "playerz", 'allen', "soccer")
new_registerPlayer("tourney_practice", "playerz", 'beverly', "soccer")
new_registerPlayer("tourney_practice", "playerz", 'cleanth', "soccer")
new_registerPlayer("tourney_practice", "playerz", 'devon', "soccer")
# new_registerPlayer("tourney_practice", "playerz", 'eldridge', "soccer")
1 + 1
new_registerPlayer("tourney_practice", "playerz", 'eldridge', "soccer")
new_registerPlayer("tourney_practice", "playerz", 'fatool', "soccer")
new_registerPlayer("tourney_practice", "playerz", 'g-money', "soccer")
new_registerPlayer("tourney_practice", "playerz", 'harold', "soccer")

1 + 1
# registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 9, 10)
# registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 11, 12)
# registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 13, 14)
# registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 15, 16)


registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 9, 10)
registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 11, 12)
registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 13, 14)
registerMatchParticipants("tourney_practice", "match_participants", "soccer", 1, 15, 16)

registerScores("tourney_practice", "score_results", 13, 1, 0)
registerScores("tourney_practice", "score_results", 14, 0, 1)
registerScores("tourney_practice", "score_results", 15, 1, 0)
registerScores("tourney_practice", "score_results", 16, 0, 1)

log_round_results("tourney_practice", "soccer", 1)
set_all_OMW('tourney_practice')

naive_swissPairings(2, "soccer")


## 
registerScores("tourney_practice", "score_results", 17, 1, 1)
registerScores("tourney_practice", "score_results", 18, 0, 1)
registerScores("tourney_practice", "score_results", 19, 1, 0)
registerScores("tourney_practice", "score_results", 20, 0, 1)

log_round_results("tourney_practice", "soccer", 2)
set_all_OMW('tourney_practice')

naive_swissPairings(3, "soccer")

registerScores("tourney_practice", "score_results", 21, 1, 0)
registerScores("tourney_practice", "score_results", 22, 0, 1)
registerScores("tourney_practice", "score_results", 23, 1, 0)
registerScores("tourney_practice", "score_results", 24, 0, 1)

log_round_results("tourney_practice", "soccer", 3)
set_all_OMW('tourney_practice')

#+END_SRC
** library code used throughout
*** connection setup--new_connect
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def new_connect(dbname):
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)

#+END_SRC
*** execute a query--new_dbExecuteWrapper
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()

#+END_SRC
*** execute a query that fetches all rows--new_dbExecuteRetrievalWrapper_allrows
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()
    return rows

#+END_SRC
*** delete table wrapper function--new_deleteTable
#+BEGIN_SRC python :session *Python* :results output :tangle yes

# deletion
def new_deleteTable(dbname, table_name):
    tb_name = table_name
    sql_keywords = """DELETE FROM """
    query = sql_keywords + tb_name
    table_nm = (table_name,)
    new_dbExecuteWrapper(query, dbname)

#+END_SRC
*** SQL syntax helpers--update_statement_string; keyword_statement_string
**** 
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def update_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """UPDATE """
    update_statement = sql_keywords + tb_name
#+END_SRC
**** 
#+BEGIN_SRC python :session *Python* :results output :tangle yes
# used in registerMatchParticipants
def keyword_statement_string(table_name, sql_keyword):
    tb_name = table_name
    sql_keywords = sql_keyword + """ """
    update_statement = sql_keywords + tb_name + """ """
    return update_statement
#+END_SRC
*** functions needed strictly for original tests
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def deletePlayers():
    new_deleteTable("tourney_practice", "playerz")


def deleteMatches():
    new_deleteTable("tourney_practice", "matchez")


# original Python db interaction
def new_countPlayers(dbname, table_name):
    DB = new_connect(dbname)
    c = DB.cursor()
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT count(*)" + from_statement + ";"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    DB.close()
    return int(row_item[0])
#+END_SRC
** old test stubs plus specs for new functionality
*** register player for specific tournament--new_registerPlayer
**** potential issues or documentation
- what happens if more than one player registers with the same name?
- can a player register for more than one tournament?
- given a certain number of participants, does it matter how many
  rounds will be in a given tournament?
**** original code
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_registerPlayer(dbname, table_name, player_name, tournament_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name, tournament_name)" +
             "VALUES (%s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, tournament_name))
#+END_SRC
*** create participants (and a match) for a given round of a given tournament--registerMatchParticipants
**** potential issues
- you have to know the player id rather than the player name?
  - solution: print out names and matching ids for a given tournament
- you have to know what round this match will be in of what tournament?
  - solution: gather data on what round(s) the given player has been in
**** original code
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def registerMatchParticipants(dbname, table_name, sport, round_no, player_id1, player_id2):
    participant_insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query2 = (participant_insert_statement + "(home, away)" + "VALUES (%s, %s);")
    new_dbExecuteWrapper(query2, dbname, (player_id1, player_id2))
    match_update_statement = keyword_statement_string("""matchez""", """UPDATE""")
    query1 = (match_update_statement +
              "SET tournament_name= (%s), round = (%s) WHERE tournament_name= 'none';")
    new_dbExecuteWrapper(query1, dbname, (sport, round_no))
#+END_SRC
**** relies on an SQL trigger
*** register a score for a given match--registerScores
**** 
- you have to know the match_id in order to register the scores?
- scores are expected to be positive integers, and ties are possible
  (except in the first round)?
- relies on a notion of an arbitrary home and away team
**** original code
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def registerScores(dbname, table_name, match_no, home_score, away_score):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, home_score, away_score))
#+END_SRC
*** log the data from the results of a given round--log_round_results
**** 
- you have to know what round of which tournament has been completed?
- a lot happens here, primarily the determining of a Points value for
  each participant depending on a victory or a tie?
**** original code
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def log_round_results(dbname, tournament_name, round_of_tournament):
    query = "SELECT * FROM log_records(%s, %s)"
    new_dbExecuteWrapper(query, dbname, (round_of_tournament, tournament_name))
#+END_SRC
*** create an Opponents Match Win value for each player--set_all_OMW
**** 
- you have to compute the OMW for each player in the db?
- is not really OM Wins but OM points
**** original code
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def set_all_OMW(dbname):
    data = how_many_players(dbname)
    playaz = [n[0] for n in data]
    [set_OMW(dbname, n) for n in playaz]
    print("done")

#+END_SRC
**** relies on
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def how_many_players(dbname):
    query = "select * from player_recordz;"
    return new_dbExecuteRetrievalWrapper_allrows(dbname, query)


def set_OMW(dbname, player_id):
    query = "SELECT * FROM set_omw(%s);"
    new_dbExecuteWrapper(query, dbname, (player_id,))

#+END_SRC
*** create the pairings for the next round and register them as matches--naive_swissPairings
**** 
- the implementation of swiss pairings does a lot, and depends on a
  view of the player records for a given tournament?
- why does the function need to know what round you are calculating for?
**** original code
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def naive_swissPairings(round_no, tournament_name):
    next_round = naive_pairings(tournament_name)
    for pair in next_round:
        registerMatchParticipants("tourney_practice", "match_participants", tournament_name, round_no, pair[0], pair[1])

#+END_SRC
**** relies on
#+BEGIN_SRC python :session *Python* :results output :tangle yes

def new_playerStandings_alt(dbname, table_name, tournament_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT * " + from_statement + "WHERE tournament_name = (%s) ORDER BY points DESC, omw DESC;"
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query, (tournament_name,))
    rows = c.fetchall()
    DB.close()
    return rows
#    return new_dbExecuteRetrievalWrapper_allrows(dbname, query, tournament_name)

# conatins hard-coded db and table (the wrong table originally!)

def naive_pairings(tournament_name):
    pairings = []
    tables = new_playerStandings_alt("tourney_practice", "player_tables", tournament_name)
    [id1, id2, id3, id4, id5, id6, id7, id8] = [row[0] for row in tables]
    pairings = [(id1, id2), (id3, id4), (id5, id6), (id7, id8)]
    return pairings

#+END_SRC
*** delete Matches
**** unnecessary to ever delete Players or Matches for new codebase?
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testDeleteMatches():
#+END_SRC
*** deleteMatches and deletePlayers
**** unnecessary to ever delete Players or Matches for new codebase?

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testDelete():
#+END_SRC
*** countPlayers--returns 0 after deleting Matches and Players
**** stub
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testCount():
#+END_SRC
**** needed to see if registration worked
*** register--countPlayers returns correct number?
**** registration
**** stub
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testRegister():
#+END_SRC

*** register + countdelete
**** registering more than one creates correct number as does deleting
**** stub
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testRegisterCountDelete():
#+END_SRC
*** standings before matches
**** playerStandings
- appearance in standings before matches played
- registered players only in standings
- number of columns in standings is 4
- columns should be empty before matches played
- names should appear in the standing even before matches played
**** stub

#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testStandingsBeforeMatches():
#+END_SRC
*** report Matches
**** spec
- players should a match recorded
- winner should have a win recorded
- losers should have zero wins recorded
**** stub
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testReportMatches():
#+END_SRC
*** create pairing
**** spec
- registering four players and reporting two matches between them,
  should produce a standings table that SwissPairings uses to match
  players with one match
**** stub
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def testPairings():
#+END_SRC

