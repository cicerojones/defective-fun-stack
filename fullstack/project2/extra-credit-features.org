* extra credit features
** initial planning
*** natural planning
So basically, 

1. register some number of players greater than 4
   - work off an existing round number type of tournament
2. report an intial set of victories with reportMatches
   - plan how to set up the first batch of matches
     - 1 d. 2
     - 3 d. 4
     - etc.
3. tinker with swissPairings
   - add a clause that looks at entries in matches
4. use tourney_practice to experiment with the correct raw SQL 

|                    | "Twilight Sparkle" | "Fluttershy" | "Applejack" | "Pinkie Pie" | "Bruno Walton" | "Boots O'Neal" | "Cathy Burton" | "Diane Grant" |
|--------------------+--------------------+--------------+-------------+--------------+----------------+----------------+----------------+---------------|
| "Twilight Sparkle" | nil                |              |             |              |                |                |                |               |
| "Fluttershy"       |                    |              |             |              |                |                |                |               |
| "Applejack"        |                    |              |             |              |                |                |                |               |
| "Pinkie Pie"       |                    |              |             |              |                |                |                |               |
| "Bruno Walton"     |                    |              |             |              |                |                |                |               |
| "Boots O'Neal"     |                    |              |             |              |                |                |                |               |
| "Cathy Burton"     |                    |              |             |              |                |                |                |               |
| "Diane Grant"      |                    |              |             |              |                |                |                |               |
*** 4 abcd
| match no. | winner | loser |
|-----------+--------+-------|
|         1 | a      | b     |
|         2 | c      | d     |
|-----------+--------+-------|
|         3 | a      | c     |
|         4 | b      | d     |
|         5 |        |       |
|         6 |        |       |
|         7 |        |       |
|         8 |        |       |
|         9 |        |       |
|        10 |        |       |
|        11 |        |       |
|        12 |        |       |
|        13 |        |       |
|        14 |        |       |
|        15 |        |       |
|        16 |        |       |
*** 8 abcdefgh
| match no. | winner | loser | win_id | lose_id | winner record | loser record |
|-----------+--------+-------+--------+---------+---------------+--------------|
|         1 | a      | b     |      1 |       2 |           0-0 |          0-0 |
|         2 | c      | d     |      3 |       4 |           0-0 |          0-0 |
|         3 | e      | f     |      5 |       6 |           0-0 |          0-0 |
|         4 | g      | h     |      7 |       8 |           0-0 |          0-0 |
|-----------+--------+-------+--------+---------+---------------+--------------|
|         5 | a      | c     |      1 |       3 |           1-0 |          1-0 |
|         6 | e      | g     |      5 |       7 |           1-0 |          1-0 |
|         7 | b      | d     |      2 |       4 |           0-1 |          0-1 |
|         8 | f      | h     |      6 |       8 |           0-1 |          0-1 |
|-----------+--------+-------+--------+---------+---------------+--------------|
|         9 | a      | e     |      1 |       5 |           2-0 |          2-0 |
|        10 | b      | c     |      2 |       3 |           1-1 |          1-1 |
|        11 | f      | g     |      6 |       7 |           1-1 |          1-1 |
|        12 | d      | h     |      4 |       8 |           0-2 |          0-2 |
|-----------+--------+-------+--------+---------+---------------+--------------|


| team | wins | losses | avg. wins of teams lost to |   |
|------+------+--------+----------------------------+---|
| a    |    3 |      0 |                          - |   |
| b    |    2 |      1 |                          3 |   |
| f    |    2 |      1 |                          1 |   |
| c    |    1 |      2 |                            |   |
| d    |    1 |      2 |                            |   |
| e    |    1 |      2 |                            |   |
| g    |    1 |      2 |                            |   |
| h    |    0 |      3 |                            |   |

*** 16 players
a. 
b. 
c. 
d. 
e. 
f. 
g. 
h. 

i. 
j. 
k. 
l. 
m. 
n. 
o. 
p. 

*** number pairs to return!
    "For four players, swissPairings should return two pairs."
For eight players, what number of pairs to return?
Well, you'd need to report an initial group of 4 matches.

So, whereas the test for the meets specifications starts off so:

#+BEGIN_SRC python
registerPlayer("Twilight Sparkle")
    registerPlayer("Fluttershy")
    registerPlayer("Applejack")
    registerPlayer("Pinkie Pie")
    standings = playerStandings()
    [id1, id2, id3, id4] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
#+END_SRC

We would instead do something like

#+BEGIN_SRC python
registerPlayer("Twilight Sparkle")
registerPlayer("Fluttershy")
registerPlayer("Applejack")
registerPlayer("Pinkie Pie")

    registerPlayer("Bruno Walton")
    registerPlayer("Boots O'Neal")
    registerPlayer("Cathy Burton")
    registerPlayer("Diane Grant")

    standings = playerStandings()
    [id1, id2, id3, id4, id5, id6, id7, id8] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
    reportMatch(id5, id6)
    reportMatch(id7, id8)
#+END_SRC
** Prevent rematches between players.
** odd number of players requires a bye
 Don’t assume an even number of players. If there is an odd number of
 players, assign one player a “bye” (skipped round). A bye counts as a
 free win. A player should not receive more than one bye in a
 tournament.
** allow ties
 Support games where a draw (tied game) is possible. This will require
 changing the arguments to reportMatch.
** use Opponent Match Wins as criteria for breaking ties in ranking
 When two players have the same number of wins, rank them according to
 OMW (Opponent Match Wins), the total number of wins by players they
 have played against.
** Support more than one tournament in the database
 Support more than one tournament in the database, so matches do not
 have to be deleted between tournaments. This will require
 distinguishing between “a registered player” and “a player who has
 entered in tournament #123”, so it will require changes to the
 database schema.
** You may refer to outside resources to devise your pairing algorithm.
Wizards of the Coast has prepared simple instructions, and more
details can be found in resources linked to in the reference section
of Wikipedia's article on Swiss tournaments.

* Python code that passes basic tests
**  connect():
*** original, with 'tournament' as dbname
#+BEGIN_SRC python :session *Python* :results output
import psycopg2


def connect():
    """Connect to the PostgreSQL database.  Returns a database connection."""
    return psycopg2.connect("dbname=tournament")

#+END_SRC

#+RESULTS:

*** original, with 'tourney_practice' as dbname
#+BEGIN_SRC python :session *Python* :results output
import psycopg2


def connect():
    """Connect to the PostgreSQL database.  Returns a database connection."""
    return psycopg2.connect("dbname=tourney_practice")

#+END_SRC

#+RESULTS:

*** refactor 'connect' to take a dbname argument
#+BEGIN_SRC python :session *Python* :results output
import psycopg2

def new_connect(dbname):
    """Connect to the PostgreSQL database.  Returns a database connection."""
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)

#+END_SRC

#+RESULTS:
**  dbExecuteWrapper(query_string, extra=None):
*** original
'extra' parameter gets used when calling an INSERT query 
#+BEGIN_SRC python :session *Python* :results output

# refactor to use connect() for final version
def dbExecuteWrapper(query_string, extra=None):
    DB = connect()
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC


*** refactor for varying databases
#+BEGIN_SRC python :session *Python* :results output

# refactor to use connect() for final version
def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

*** use new_dbExecuteWrapper with new_connect and tourney_practice
#+BEGIN_SRC python :session *Python* :results output
new_dbExecuteWrapper(
#+END_SRC
**  dbExecuteRetrievalWrapper_allrows(query_string):
*** original
doesn't work as a babel block without 'return' statement last
#+BEGIN_SRC python :session *Python* :results output

def dbExecuteRetrievalWrapper_allrows(query_string):
    DB = connect()
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()
    return rows

#+END_SRC

#+RESULTS:
*** example of original


#+BEGIN_SRC python :session *Python* :results output
dbExecuteRetrievalWrapper_allrows("select * from players2")
#+END_SRC

#+RESULTS:
: [(218, 'Fluttershy', 0, 1), (217, 'Twilight Sparkle', 1, 1), (220, 'Pinkie Pie', 0, 1), (219, 'Applejack', 1, 1)]

**  deleteMatches():
*** original
#+BEGIN_SRC python :session *Python* :results output
# refactor all queries into a variable that is then passed to execute

def deleteMatches():
    query = """DELETE FROM matches;"""
    dbExecuteWrapper(query)

#+END_SRC
*** refactor to vary databases and tables
#+BEGIN_SRC python :session *Python* :results output
# refactor all queries into a variable that is then passed to execute

def new_deleteTable(dbname, table_name):
    query = """DELETE FROM (%s);"""
    dbExecuteWrapper(query, dbname, (table_name,))

#+END_SRC

#+RESULTS:

*** call delete with "tourney_practice" arguments
#+BEGIN_SRC python :session *Python* :results output
deleteTable(tourney_practice, matches2)
#+END_SRC
**  deletePlayers():
*** original
#+BEGIN_SRC python :session *Python* :results output
def deletePlayers():
    query = """DELETE FROM players;"""
    dbExecuteWrapper(query)

#+END_SRC
*** refactor to take a table name as argument
#+BEGIN_SRC python :session *Python* :results output
def deletePlayers():
    query = """DELETE FROM players;"""
    dbExecuteWrapper(query)

#+END_SRC
**  countPlayers():
*** original
#+BEGIN_SRC python :session *Python* :results output
def countPlayers():
    DB = connect()
    c = DB.cursor()
    query = "SELECT count(*) FROM players;"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    return int(row_item[0])
    DB.close()

#+END_SRC
**  registerPlayer(name):
*** original
# Some kind of problem using _allrows with multiline string formatting

#+BEGIN_SRC python :session *Python* :results output
def registerPlayer(name):
    query = ("INSERT INTO players (player_name, wins, matches)"
             "VALUES (%s, %s, %s);")
    dbExecuteWrapper(query, (name, 0, 0))
#+END_SRC

*** define registerPlayer with players2 as table 
#+BEGIN_SRC python :session *Python* :results output
def registerPlayer(name):
    query = ("INSERT INTO players2 (player_name, wins, matches)"
             "VALUES (%s, %s, %s);")
    dbExecuteWrapper(query, (name, 0, 0))


# Some kind of problem using _allrows with multiline string formatting
#+END_SRC

*** register some players
#+BEGIN_SRC python :session *Python* :results output
registerPlayer("A")
registerPlayer("B")
registerPlayer("C")
registerPlayer("D")
registerPlayer("E")
registerPlayer("F")
registerPlayer("G")
registerPlayer("H")
registerPlayer("I")
registerPlayer("J")
registerPlayer("K")
registerPlayer("L")
registerPlayer("M")
registerPlayer("N")
registerPlayer("O")
registerPlayer("P")
#+END_SRC

#+RESULTS:

*** register some players with table playerz
#+BEGIN_SRC python :session *Python* :results output
new_registerPlayer("A", "playerz")
new_registerPlayer("B", "playerz")
new_registerPlayer("C", "playerz")
new_registerPlayer("D", "playerz")
new_registerPlayer("E", "playerz")
new_registerPlayer("F", "playerz")
new_registerPlayer("G", "playerz")
new_registerPlayer("H", "playerz")
new_registerPlayer("I", "playerz")
new_registerPlayer("J", "playerz")
new_registerPlayer("K", "playerz")
new_registerPlayer("L", "playerz")
new_registerPlayer("M", "playerz")
new_registerPlayer("N", "playerz")
new_registerPlayer("O", "playerz")
new_registerPlayer("P", "playerz")
#+END_SRC

**  playerStandings():
#+BEGIN_SRC python :session *Python* :results output
def playerStandings():
    query = ("SELECT id, player_name, wins, matches "
             "FROM players ORDER BY wins DESC;")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC
**  reportMatch(winner, loser):
#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    query1 = ("INSERT INTO matches VALUES (%s, %s) ;")
    query2 = ("UPDATE players SET wins = wins + 1"
              "FROM matches WHERE players.id = (%s) ;")
    query3 = ("UPDATE players SET matches = matches + 1"
              "FROM matches WHERE players.id = (%s) OR players.id = (%s);")
    dbExecuteWrapper(query1, (winner, loser))
    dbExecuteWrapper(query2, (winner,))
    dbExecuteWrapper(query3, (winner, loser))

#+END_SRC

**  swissPairings():
#+BEGIN_SRC python :session *Python* :results output
def swissPairings():
    query = ("SELECT a.id, a.player_name, b.id, b.player_name "
             "FROM players as a, players as b "
             "WHERE a.wins = b.wins "
             "AND a.player_name != b.player_name "
             "AND a.id < b.id")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC
* new_ suite of functions--create, update, delete--using wrapper function
** start here this works
*** import psycopg and define a db-agnostic connect function
**** def new_connect(dbname):						:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
import psycopg2

def new_connect(dbname):
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)
#+END_SRC
*** define a db-agnostic execute wrapper
**** def new_dbExecuteWrapper(query_string, dbname, extra=None):	:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC
*** define a db-agnostic retrieval wrapper
**** def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):	:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()    
    return rows

#+END_SRC

#+RESULTS:

*** define a db and table-agnostic deleteTable function
**** def new_deleteTable(dbname, table_name):				:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_deleteTable(dbname, table_name):
    tb_name = table_name
    sql_keywords = """DELETE FROM """
    query = sql_keywords + tb_name
    table_nm = (table_name,)
    new_dbExecuteWrapper(query, dbname)
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "matchez")
#+END_SRC    

#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "playerz")
#+END_SRC    

#+RESULTS:

*** use new_deleteTable to define deleteMatches and deletePlayers function
**** deleteTable matchez and playerz
#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "matchez")
#+END_SRC    

#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "playerz")
#+END_SRC    
*** countPlayers
**** refactor to take table name as argument--must return as last line?
#+BEGIN_SRC python :session *Python* :results output
def countPlayers():
    DB = connect()
    c = DB.cursor()
    query = "SELECT count(*) FROM players;"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    return int(row_item[0])
    DB.close()

#+END_SRC
**** def new_countPlayers(dbname, table_name):				:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_countPlayers(dbname, table_name):
    DB = new_connect(dbname)
    c = DB.cursor()
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT count(*)" + from_statement + ";"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    DB.close()
    return int(row_item[0])


#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
new_countPlayers("tourney_practice", "playerz")
#+END_SRC

#+RESULTS:
: 3

*** refactor registerPlayer to take a table_name argument
**** assumes columns have certain hard-coded names
#+BEGIN_SRC python :session *Python* :results output
def new_registerPlayer(dbname, table_name, player_name):
    tb_name = table_name
    sql_keywords = """INSERT INTO """
    insert_statement = sql_keywords + tb_name
    query = (insert_statement + "(player_name, wins, matchez)"
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, 0, 0))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :session *Python* :results output
new_registerPlayer("tourney_practice", "playerz", "CCCC")
#+END_SRC

#+RESULTS:
**** make a general INSERT statement string generator
#+BEGIN_SRC python :session *Python* :results value
def insert_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """INSERT INTO """
    insert_statement = sql_keywords + tb_name
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results value
insert_statement_string("matchez")
#+END_SRC

#+RESULTS:

**** make a general UPDATE statement string generator
#+BEGIN_SRC python :session *Python* :results output
def update_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """UPDATE """
    update_statement = sql_keywords + tb_name
#+END_SRC
**** make a general SQL KEYWORD + tablename statement string generator	
**** def keyword_statement_string(table_name, sql_keyword):		:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def keyword_statement_string(table_name, sql_keyword):
    tb_name = table_name
    sql_keywords = sql_keyword + """ """
    update_statement = sql_keywords + tb_name + """ """
    return update_statement
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
keyword_statement_string("matchez", "FROM")
#+END_SRC

#+RESULTS:
: 'FROM matchez '

**** def new_registerPlayer(dbname, table_name, player_name):		:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_registerPlayer(dbname, table_name, player_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name, wins, matchez)" + 
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, 0, 0))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
new_registerPlayer("tourney_practice", "playerz", "AAAA")
new_registerPlayer("tourney_practice", "playerz", "BBBB")
new_registerPlayer("tourney_practice", "playerz", "CCCC")
new_registerPlayer("tourney_practice", "playerz", "DDDD")
#+END_SRC

#+RESULTS:

*** refactor playerStandings
**** def new_playerStandings(table_name)--assumes columns with hard-coded names :def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_playerStandings(table_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = ("SELECT id, player_name, wins, matchez " +
             from_statement + "ORDER BY wins DESC;")
    return new_dbExecuteRetrievalWrapper_allrows("tourney_practice", query)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
new_playerStandings("playerz")
#+END_SRC

#+RESULTS:
: [(1, 'AAAA', 1, 1), (2, 'BBBB', 0, 1), (3, 'CCCC', 0, 0)]
*** refactor reportMatch(winner, loser):
**** original contains matches and players table names
#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    query1 = ("INSERT INTO matches VALUES (%s, %s) ;")
    query2 = ("UPDATE players SET wins = wins + 1"
              "FROM matches WHERE players.id = (%s) ;")
    query3 = ("UPDATE players SET matches = matches + 1"
              "FROM matches WHERE players.id = (%s) OR players.id = (%s);")
    dbExecuteWrapper(query1, (winner, loser))
    dbExecuteWrapper(query2, (winner,))
    dbExecuteWrapper(query3, (winner, loser))

#+END_SRC
**** def new_reportMatch(dbname, table1, table2, winner, loser)--still hard codes column names :def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_reportMatch(dbname, table1, table2, winner, loser):
    q1_insert = keyword_statement_string(table2, """INSERT INTO""")
    q2_update = keyword_statement_string(table1, """UPDATE""")
    q2_from = keyword_statement_string(table2, """FROM""")
    query1 = (q1_insert + "VALUES (%s, %s) ;")
    query2 = (q2_update + "SET wins = wins + 1" + 
              q2_from + "WHERE playerz.id = (%s);")
    query3 = (q2_update + "SET matchez = matchez + 1" + 
              q2_from + "WHERE playerz.id = (%s) OR playerz.id = (%s);")
    new_dbExecuteWrapper(query1, dbname, (winner, loser))
    new_dbExecuteWrapper(query2, dbname, (winner,))
    new_dbExecuteWrapper(query3, dbname, (winner, loser))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :session *Python* :results output
new_reportMatch("tourney_practice", "playerz", "matchez", 1, 2)
#+END_SRC

#+RESULTS:


*** swissPairings() will require more clauses?
#+BEGIN_SRC python :session *Python* :results output
def swissPairings():
    query = ("SELECT a.id, a.player_name, b.id, b.player_name "
             "FROM players as a, players as b "
             "WHERE a.wins = b.wins "
             "AND a.player_name != b.player_name "
             "AND a.id < b.id")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC
** steps
1. drop tables
2. redefine tablez for tourney_practice with sql statements
3. create players using bare sql in CLI
4. delete matches first function
   - using deleteTable function that takes a table name to delete all
     rows from
   - got stuck on imitating passing VALUES () sql syntax i.e. adding
     parens where unnecessary in a straight DELETE FROM statement
   - trouble using new_deleteTable that takes a db name as well, as a tablename
     - [[*define new deleteTable that takes a database name as well][define new deleteTable that takes a database name as well]]
     - syntax error: LINE 1: DELETE FROM 'matchez';
       - why is the argument getting passed with single-quotes
       - i.e. of the two following code blocks, the first doesn't
         work, while the second does
5. delete anything using new_dbexecuteWrapper
   - test out new_connect
     - in order to test new_connect using a delete, need to register
       players and report matches between them
       - where is this done?
	 - DROP matchez and playerz tables; then create new with bare SQL
	 - check from psql SELECT *
	 - INSERT INTO playerz from psql
	 - use reportMatch_tourney(1, 2) as above
	   - [[*call reportMatch_tourney][call reportMatch_tourney]]
	   - check from psql SELECT *
6. refactor reportMatches to take db, and two table names
   - still contains hard-coded references to column names
7. refactor registerPlayer to take db, table name

* planning steps toward implementing OMW
** 1. clear tourney practice of playerz and matchez tables 
*** do this from org-babel
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz; DROP TABLE matchez;
    #+END_SRC

    #+RESULTS:
    | DROP TABLE |
    |------------|
    | DROP TABLE |
*** check that you have emptied
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from playerz;
    #+END_SRC

    #+RESULTS:




    | id | player_name | wins | matchez | omw |
    |----+-------------+------+---------+-----|
    |  1 | a           |    0 |       0 |   0 |
    |  2 | b           |    0 |       0 |   0 |
    |  3 | c           |    0 |       0 |   0 |
    |  4 | d           |    0 |       0 |   0 |
    |  5 | e           |    0 |       0 |   0 |
    |  6 | f           |    0 |       0 |   0 |
    |  7 | g           |    0 |       0 |   0 |
    |  8 | h           |    0 |       0 |   0 |

** 2. setup tables
*** simple version for basic credit
    #+BEGIN_SRC sql
CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer); CREATE TABLE matchez(winner integer, loser integer);
    #+END_SRC
*** extended version for extra credit
**** sql
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer, OMW integer); CREATE TABLE matchez(match_id serial, winner integer, loser integer); 
    #+END_SRC

    #+RESULTS:
    | CREATE TABLE |
    |--------------|
    | CREATE TABLE |
**** consider more than two tables
1. use players for players stats
| player_id | player_name | wins | matches | omw |
2. use matches to register 'result'
   - include scores? in order to accomodate ties?
3. use a winners table and a losers table
winners:
| match_id | player_id |

losers:
| match_id | player_id |
** 3. register some players
*** original version where playerz have a 'name', wins and matches
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name, wins, matchez) VALUES ('a', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('b', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('c', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('d', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('e', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('f', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('g', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('h', 0, 0);
    #+END_SRC
*** INSERT players into playerz but provide an 'opponent matches wins' argument
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('a', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('b', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('c', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('d', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('e', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('f', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('g', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('h', 0, 0, 0);
    #+END_SRC

** 4. make a query to update OMW when a Match is reported
*** use update playerz 
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 from matchez where playerz.id = matchez.loser;
    #+END_SRC
** 5. report some Matches to start building new functionality
   - many sub steps to reporting Matches functionality
   - ultimately will need an autoincrementing matchID column to
     distinguish matches and rounds

*** round 1 interactions
**** reportMatches using SQL
***** insert four round 1 matches
      #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 2);
INSERT INTO matchez (winner, loser) VALUES (3, 4);
INSERT INTO matchez (winner, loser) VALUES (5, 6);
INSERT INTO matchez (winner, loser) VALUES (7, 8);
      #+END_SRC

      #+RESULTS:
      | INSERT 0 1 |
      |------------|
      | INSERT 0 1 |
      | INSERT 0 1 |
      | INSERT 0 1 |

***** after round1 all swissPairings will be:

      #+RESULTS:
      | id | player_name | id | player_name |
      |----+-------------+----+-------------|
      |  2 | b           |  8 | h           |
      |  2 | b           |  4 | d           |
      |  2 | b           |  6 | f           |
      |  4 | d           |  8 | h           |
      |  4 | d           |  6 | f           |
      |  6 | f           |  8 | h           |
      |  1 | a           |  3 | c           |
      |  1 | a           |  5 | e           |
      |  1 | a           |  7 | g           |
      |  3 | c           |  5 | e           |
      |  3 | c           |  7 | g           |
      |  5 | e           |  7 | g           |
**** update players wins after first round
***** update just player 1 wins after first round
      update the wins of players with an id in the 'winner' column

      #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5;
      #+END_SRC
***** second round (match ids 5-9) update all winners
      #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 4 AND matchez.match_id < 9;
      #+END_SRC

      #+RESULTS:
      | UPDATE 4 |
      |----------|

***** long, hard-coded approach in SQL
      Is there a way in a query to not have to specify the exact player id,
      but instead to use the id of anyone whose id appears in the winner column?
      #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = 3;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 5;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 7;
      #+END_SRC

      #+RESULTS:
      | UPDATE 1 |
      |----------|
      | UPDATE 1 |
      | UPDATE 1 |

      All at once
      #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = 1;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 3;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 5;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 7;
      #+END_SRC

**** increment OMW for first round losers
***** long, hard-coded approach in SQL
      #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 2;
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 4;
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 6;
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 8;
      #+END_SRC

      #+RESULTS:
      | UPDATE 1 |
      |----------|
      | UPDATE 1 |
      | UPDATE 1 |
      | UPDATE 1 |
***** update OMW using match_ids
      #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5;
      #+END_SRC

      #+RESULTS:
      | UPDATE 4 |
      |----------|
***** rethink OMW
****** views
**** create view
     #+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE VIEW player3_matches AS
select * from matchez WHERE winner=3 or loser=3;
     #+END_SRC

     #+RESULTS:
     | CREATE VIEW |
     |-------------|
     #+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from player3_matches
     #+END_SRC

     #+RESULTS:
     | match_id | winner | loser |
     |----------+--------+-------|
     |        2 |      3 |     4 |
     |        5 |      1 |     3 |

     #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = sum(playerz.wins) FROM matchez where playerz.id = 
     #+END_SRC

     #+BEGIN_SRC sql :engine postgresql :database tourney_practice
select player_name
     #+END_SRC
     use new table for each player--opponents?
**** add a match to everyplayer--use after a full set of matches reported
     #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
     #+END_SRC

     #+RESULTS:
     | UPDATE 8 |
     |----------|

*** after round 2
**** insert round 2 results such that 'a' will play 'e' in the final
     #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3);
INSERT INTO matchez (winner, loser) VALUES (5, 7);
INSERT INTO matchez (winner, loser) VALUES (2, 4);
INSERT INTO matchez (winner, loser) VALUES (6, 8);
     #+END_SRC

     #+RESULTS:
     | INSERT 0 1 |
     |------------|
     | INSERT 0 1 |
     | INSERT 0 1 |
     | INSERT 0 1 |

     have to use results from swiss pairings
** select * playerz
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from playerz;
   #+END_SRC

   #+RESULTS:
   | id | player_name | wins | matchez | omw |
   |----+-------------+------+---------+-----|
   |  2 | b           |    0 |       0 |   0 |
   |  4 | d           |    0 |       0 |   0 |
   |  6 | f           |    0 |       0 |   0 |
   |  8 | h           |    0 |       0 |   0 |
   |  1 | a           |    1 |       0 |   0 |
   |  3 | c           |    1 |       0 |   0 |
   |  5 | e           |    1 |       0 |   0 |
   |  7 | g           |    1 |       0 |   0 |

** select all matchez
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from matchez
   #+END_SRC

   #+RESULTS:
   | winner | loser |
   |--------+-------|
   |      1 |     2 |
   |      3 |     4 |
   |      5 |     6 |
   |      7 |     8 |

* old sequence of SQL commands
** master list
*** clear and setup and insert players
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz; DROP TABLE matchez; CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer, OMW integer); CREATE TABLE matchez(match_id serial, winner integer, loser integer); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('a', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('b', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('c', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('d', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('e', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('f', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('g', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('h', 0, 0, 0); 
    #+END_SRC
psql:/var/folders/0j/3x_y7ctd2n30r1ksp6k0rcvh0000gn/T/babel-1368vcw/sql-in-1368A7x:1: 
ERROR:  cannot drop table matchez because other objects depend on it
DETAIL:  view player3_matches depends on table matchez
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

    #+RESULTS:
    | DROP TABLE |
    |------------|

    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz; DROP TABLE matchez CASCADE; CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer, OMW integer); CREATE TABLE matchez(match_id serial, winner integer, loser integer); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('a', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('b', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('c', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('d', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('e', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('f', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('g', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('h', 0, 0, 0); 
    #+END_SRC

    #+RESULTS:

*** insert winner-loser pairs for first round; update wins, OMW, matches
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 2); INSERT INTO matchez (winner, loser) VALUES (3, 4); INSERT INTO matchez (winner, loser) VALUES (5, 6); INSERT INTO matchez (winner, loser) VALUES (7, 8); update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5; update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5; update playerz set matchez = matchez + 1;
    #+END_SRC

    #+RESULTS:
    | INSERT 0 1 |
    |------------|
    | INSERT 0 1 |
    | INSERT 0 1 |
    | INSERT 0 1 |
    | UPDATE 4   |
    | UPDATE 4   |
    | UPDATE 8   |
*** insert second winner-loser pairs such that: 'a' will play 'e' in the final
    #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3); INSERT INTO matchez (winner, loser) VALUES (5, 7); INSERT INTO matchez (winner, loser) VALUES (2, 4); INSERT INTO matchez (winner, loser) VALUES (6, 8);  update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 4 AND matchez.match_id < 9; update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 4 AND matchez.match_id < 9; update playerz set matchez = matchez + 1;
    #+END_SRC

    #+RESULTS:
    | INSERT 0 1 |
    |------------|
    | INSERT 0 1 |
    | INSERT 0 1 |
    | INSERT 0 1 |
    | UPDATE 4   |
    | UPDATE 4   |
    | UPDATE 8   |

** 1. clear and setup tables again
*** original
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz; DROP TABLE matchez;
   #+END_SRC

   #+RESULTS:
   | DROP TABLE |
   |------------|
   | DROP TABLE |

   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer, OMW integer); CREATE TABLE matchez(match_id serial, winner integer, loser integer); update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5; update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5; update playerz set matchez = matchez + 1;
   #+END_SRC

   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3); INSERT INTO matchez (winner, loser) VALUES (5, 7); INSERT INTO matchez (winner, loser) VALUES (2, 4); INSERT INTO matchez (winner, loser) VALUES (6, 8); 

   #+END_SRC
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5;
   #+END_SRC
   #+RESULTS:
   | INSERT 0 1 |
   |------------|
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |

*** rethinking table design

** 2. insert players into players table
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('a', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('b', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('c', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('d', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('e', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('f', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('g', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('h', 0, 0, 0);
   #+END_SRC

   #+RESULTS:
   | INSERT 0 1 |
   |------------|
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |

** 3. insert first winner-loser pairs into matches table

*** original
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 2);
INSERT INTO matchez (winner, loser) VALUES (3, 4);
INSERT INTO matchez (winner, loser) VALUES (5, 6);
INSERT INTO matchez (winner, loser) VALUES (7, 8);
   #+END_SRC

   #+RESULTS:
   | INSERT 0 1 |
   |------------|
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |

*** take the loser id and simply update matches for that player_id
** 4. update 'wins', 'OMW', and 'matches' for the affected players

*** wins and matches
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5;
   #+END_SRC

   #+RESULTS:
   | UPDATE 4 |
   |----------|

   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1;
   #+END_SRC

*** OMW requires a different query
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5;
   #+END_SRC

   #+RESULTS:
   | UPDATE 4 |
   |----------|

** 5. insert second winner-loser pairs into matches table
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3);
INSERT INTO matchez (winner, loser) VALUES (5, 7);
INSERT INTO matchez (winner, loser) VALUES (2, 4);
INSERT INTO matchez (winner, loser) VALUES (6, 8);
   #+END_SRC

   #+RESULTS:
   | INSERT 0 1 |
   |------------|
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |

** 6. REPEAT 4--update 'wins', 'OMW', and 'matches' for the affected players
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 4 and matchez.match_id < 9;
   #+END_SRC

   #+RESULTS:
   | UPDATE 3 |
   |----------|

   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 4 and matchez.match_id < 9;
   #+END_SRC

   #+RESULTS:
   | UPDATE 3 |
   |----------|

   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
   #+END_SRC

   #+RESULTS:
   | UPDATE 8 |
   |----------|

** 7. insert third winner-loser pairs, a-e championship
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 5); INSERT INTO matchez (winner, loser) VALUES (2, 6); INSERT INTO matchez (winner, loser) VALUES (3, 7); INSERT INTO matchez (winner, loser) VALUES (4, 8);
   #+END_SRC

   #+RESULTS:
   | INSERT 0 1 |
   |------------|
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |

** 9. REPEAT 4--update 'wins', 'OMW', and 'matches' for the affected players
   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 8 and matchez.match_id < 13;
   #+END_SRC

   #+RESULTS:
   | UPDATE 4 |
   |----------|

   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 8 and matchez.match_id < 13;
   #+END_SRC

   #+RESULTS:
   | UPDATE 4 |
   |----------|

   #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
   #+END_SRC

   #+RESULTS:
   | UPDATE 8 |
   |----------|
* working on new
** list (and learn) new table names
matchez
playerz
match_participants
score_results
player_recordz

views:
tournament_matches
player_tables

** view all tables, views, and column headers
*** too many rows but
#+COMMENT: too many rows
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from matchez, playerz, match_participants, score_results;
#+END_SRC

| match_id | tournament_name |
|----------+-----------------|
|          |                 |

| player_id | player_name |
|-----------+-------------|
|           |             |

| match_id | home | away |
|----------+------+------|
|          |      |      |

| match_id | home_score | away_score |
|----------+------------+------------|
|          |            |            |

| player_id | wins | losses | draws |
|-----------+------+--------+-------|
*** tournament_matches view
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from tournament_matches
#+END_SRC

#+RESULTS:
| match_id | tournament_name | home | away | home_score | away_score |
|----------+-----------------+------+------+------------+------------|
|        1 | tennis          |    1 |    2 |         10 |          0 |
|        2 | tennis          |    3 |    4 |          0 |          0 |
|        3 | tennis          |    5 |    6 |          1 |          0 |
|        4 | tennis          |    7 |    8 |          0 |          1 |
*** player_tables view
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from player_tables;
#+END_SRC

#+RESULTS:
| player_id | player_name | wins | losses | draws |
|-----------+-------------+------+--------+-------|
|         2 | b           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         7 | g           |    1 |      0 |     0 |
|         3 | c           |    0 |      0 |     1 |
|         4 | d           |    0 |      0 |     1 |
|         8 | h           |    0 |      1 |     0 |
|         1 | a           |    1 |      1 |     0 |
|         5 | e           |    1 |      1 |     0 |
** add values to tables
*** insert into 'matchez' with tournament name
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (match_id, tournament_name) VALUES (1, 'tennis');
INSERT INTO matchez (match_id, tournament_name) VALUES (2, 'tennis');
INSERT INTO matchez (match_id, tournament_name) VALUES (3, 'tennis');
INSERT INTO matchez (match_id, tournament_name) VALUES (4, 'tennis');
INSERT INTO matchez (match_id, tournament_name) VALUES (5, 'tennis');
INSERT INTO matchez (match_id, tournament_name) VALUES (6, 'tennis');
INSERT INTO matchez (match_id, tournament_name) VALUES (7, 'tennis');
INSERT INTO matchez (match_id, tournament_name) VALUES (8, 'tennis');
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

*** insert players into 'playerz' table
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name) VALUES ('a');
INSERT INTO playerz (player_name) VALUES ('b');
INSERT INTO playerz (player_name) VALUES ('c');
INSERT INTO playerz (player_name) VALUES ('d');
INSERT INTO playerz (player_name) VALUES ('e');
INSERT INTO playerz (player_name) VALUES ('f');
INSERT INTO playerz (player_name) VALUES ('g');
INSERT INTO playerz (player_name) VALUES ('h');
#+END_SRC

   #+RESULTS:
   | INSERT 0 1 |
   |------------|
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |
   | INSERT 0 1 |

must follow...

*** insert into 'player_recordz'
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO player_recordz (player_id) VALUES (1);
INSERT INTO player_recordz (player_id) VALUES (2);
INSERT INTO player_recordz (player_id) VALUES (3);
INSERT INTO player_recordz (player_id) VALUES (4);
INSERT INTO player_recordz (player_id) VALUES (5);
INSERT INTO player_recordz (player_id) VALUES (6);
INSERT INTO player_recordz (player_id) VALUES (7);
INSERT INTO player_recordz (player_id) VALUES (8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |



#+RESULTS:
| player_id | wins | losses | draws |
|-----------+------+--------+-------|
|         1 |    0 |      0 |     0 |

*** insert into 'match_participants' with match ids and player ids
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO match_participants VALUES (1, 1, 2);
INSERT INTO match_participants VALUES (2, 3, 4);
INSERT INTO match_participants VALUES (3, 5, 6);
INSERT INTO match_participants VALUES (4, 7, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from match_participants;
#+END_SRC

#+RESULTS:
| match_id | home | away |
|----------+------+------|
|        1 |    1 |    2 |
|        2 |    3 |    4 |
|        3 |    5 |    6 |
|        4 |    7 |    8 |

*** insert into score_results respective home-away scores for corresponding match_ids
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO score_results VALUES (1, 10, 0);
INSERT INTO score_results VALUES (2, 0, 0);
INSERT INTO score_results VALUES (3, 1, 0);
INSERT INTO score_results VALUES (4, 0, 1);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |


#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from score_results;
#+END_SRC

#+RESULTS:
| match_id | home_score | away_score |
|----------+------------+------------|
|        1 |         10 |          0 |
|        2 |          0 |          0 |
|        3 |          1 |          0 |
|        4 |          0 |          1 |

*** update player_recordz directly, still using tournament_matches view
**** clear all
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET wins = 0, losses = 0, draws = 0;
select * from player_tables;
#+END_SRC

#+RESULTS:
|  UPDATE 8 |             |      |        |       |
|-----------+-------------+------+--------+-------|
| player_id | player_name | wins | losses | draws |
|         1 | a           |    0 |      0 |     0 |
|         2 | b           |    0 |      0 |     0 |
|         3 | c           |    0 |      0 |     0 |
|         4 | d           |    0 |      0 |     0 |
|         5 | e           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         7 | g           |    0 |      0 |     0 |
|         8 | h           |    0 |      0 |     0 |

**** away wins
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET wins = wins + 1
from tournament_matches as a 
WHERE a.home_score < a.away_score
AND a.home = player_id;

select * from player_tables
#+END_SRC

#+RESULTS:
|  UPDATE 1 |             |      |        |       |
|-----------+-------------+------+--------+-------|
| player_id | player_name | wins | losses | draws |
|         1 | a           |    0 |      0 |     0 |
|         2 | b           |    0 |      0 |     0 |
|         3 | c           |    0 |      0 |     0 |
|         4 | d           |    0 |      0 |     0 |
|         5 | e           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         8 | h           |    0 |      0 |     0 |
|         7 | g           |    1 |      0 |     0 |

**** home wins
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET wins = wins + 1
from tournament_matches as a 
WHERE a.home_score > a.away_score
AND a.home = player_id;

select * from player_tables
#+END_SRC

#+RESULTS:
|  UPDATE 2 |             |      |        |       |
|-----------+-------------+------+--------+-------|
| player_id | player_name | wins | losses | draws |
|         2 | b           |    0 |      0 |     0 |
|         3 | c           |    0 |      0 |     0 |
|         4 | d           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         8 | h           |    0 |      0 |     0 |
|         7 | g           |    1 |      0 |     0 |
|         1 | a           |    1 |      0 |     0 |
|         5 | e           |    1 |      0 |     0 |

**** draws
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET draws = draws + 1
from tournament_matches as a 
WHERE a.home_score = a.away_score
AND (a.home = player_id OR a.away = player_id);

select * from player_tables
#+END_SRC

#+RESULTS:
|  UPDATE 2 |             |      |        |       |
|-----------+-------------+------+--------+-------|
| player_id | player_name | wins | losses | draws |
|         2 | b           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         8 | h           |    0 |      0 |     0 |
|         7 | g           |    1 |      0 |     0 |
|         1 | a           |    1 |      0 |     0 |
|         5 | e           |    1 |      0 |     0 |
|         3 | c           |    0 |      0 |     1 |
|         4 | d           |    0 |      0 |     1 |

**** home losses
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET losses = losses + 1
from tournament_matches as a 
WHERE a.home_score < a.away_score
AND a.away = player_id;

select * from player_tables
#+END_SRC

#+RESULTS:
|  UPDATE 1 |             |      |        |       |
|-----------+-------------+------+--------+-------|
| player_id | player_name | wins | losses | draws |
|         2 | b           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         7 | g           |    1 |      0 |     0 |
|         1 | a           |    1 |      0 |     0 |
|         5 | e           |    1 |      0 |     0 |
|         3 | c           |    0 |      0 |     1 |
|         4 | d           |    0 |      0 |     1 |
|         8 | h           |    0 |      1 |     0 |

**** away losses
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET losses = losses + 1
from tournament_matches as a 
WHERE a.home_score > a.away_score
AND a.home = player_id;

select * from player_tables
#+END_SRC

#+RESULTS:
|  UPDATE 2 |             |      |        |       |
|-----------+-------------+------+--------+-------|
| player_id | player_name | wins | losses | draws |
|         2 | b           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         7 | g           |    1 |      0 |     0 |
|         3 | c           |    0 |      0 |     1 |
|         4 | d           |    0 |      0 |     1 |
|         8 | h           |    0 |      1 |     0 |
|         1 | a           |    1 |      1 |     0 |
|         5 | e           |    1 |      1 |     0 |

*** insert second winner-loser pairs into matches table
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3);
INSERT INTO matchez (winner, loser) VALUES (5, 7);
INSERT INTO matchez (winner, loser) VALUES (2, 4);
INSERT INTO matchez (winner, loser) VALUES (6, 8);
#+END_SRC

  #+RESULTS:
  | INSERT 0 1 |
  |------------|
  | INSERT 0 1 |
  | INSERT 0 1 |
  | INSERT 0 1 |

*** REPEAT 4--update 'wins', 'OMW', and 'matches' for the affected players
**** 
 #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 4 and matchez.match_id < 9;
 #+END_SRC

 #+RESULTS:
 | UPDATE 3 |
 |----------|

 #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 4 and matchez.match_id < 9;
 #+END_SRC

 #+RESULTS:
 | UPDATE 3 |
 |----------|

 #+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
 #+END_SRC

 #+RESULTS:
 | UPDATE 8 |
 |----------|

**** insert third winner-loser pairs, a-e championship
 #+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 5); INSERT INTO matchez (winner, loser) VALUES (2, 6); INSERT INTO matchez (winner, loser) VALUES (3, 7); INSERT INTO matchez (winner, loser) VALUES (4, 8);
 #+END_SRC

 #+RESULTS:
 | INSERT 0 1 |
 |------------|
 | INSERT 0 1 |
 | INSERT 0 1 |
 | INSERT 0 1 |

**** REPEAT 4--update 'wins', 'OMW', and 'matches' for the affected players
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 8 and matchez.match_id < 13;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 8 and matchez.match_id < 13;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
#+END_SRC

#+RESULTS:
| UPDATE 8 |
|----------|

** work on creating tables
*** matches (are unique events)
matches--should have a column showing that there was a clear winner or not?
| match_id (primary) | tournament_name |
|--------------------+-----------------|
|                  1 | tennis          |
|                  2 | soccer          |
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE matchez(
       match_id serial PRIMARY KEY,
       tournament_name text not null); 
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|

*** playerz
players
| player_id (primary key) | player_name |
|-------------------------+-------------|
|                       1 | 'a'         |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE playerz (
       player_id serial PRIMARY KEY,
       player_name text not null);
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|

*** match_participants
match participants
| match_id | home_participant | away_participant |
|----------+------------------+------------------|
|        1 |                1 |                2 |
|        2 |                3 |                4 |
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE match_participants(
       match_id int REFERENCES matchez (match_id),
       home int REFERENCES playerz (player_id),
       away int REFERENCES playerz (player_id)
);
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|

*** score_results
winners
| match_id (foreign key) | home_score | away_score |
|------------------------+------------+------------|
|                      1 |         10 |          0 |
|                      2 |          0 |          0 |
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE score_results (
       match_id int REFERENCES matchez (match_id),
       home_score int,
       away_score int);
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|



#+RESULTS:
| match_id | home_score | away_score |
|----------+------------+------------|
|        1 |         10 |          0 |
|        2 |          0 |          0 |
|        3 |          1 |          0 |
|        4 |          0 |          1 |

*** player_recordz
**** original (no OMW)
players match data
| player_id (foreign key) | wins | losses | draws |
|-------------------------+------+--------+-------|
|                       1 |    1 |      0 |     0 |
|                       2 |    0 |      0 |     1 |
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE player_recordz (
       player_id int REFERENCES playerz (player_id),
       wins int DEFAULT 0,
       losses int DEFAULT 0,
       draws int DEFAULT 0);
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from player_recordz
#+END_SRC

#+RESULTS:
| player_id | wins | losses | draws |
|-----------+------+--------+-------|
|         2 |    0 |      0 |     0 |
|         3 |    0 |      0 |     0 |
|         4 |    0 |      0 |     0 |
|         6 |    0 |      0 |     0 |
|         7 |    0 |      0 |     0 |
|         8 |    0 |      0 |     0 |
|         1 |    2 |      0 |     0 |
|         5 |    2 |      0 |     0 |

**** player_recordz with OMW
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE player_recordz (
       player_id int REFERENCES playerz (player_id),
       wins int DEFAULT 0,
       losses int DEFAULT 0,
       draws int DEFAULT 0,
       OPW int DEFAULT);
#+END_SRC
*** players faced?
| player_id (foreign) | opponent_player_id |
|---------------------+--------------------|
|                   1 | 2                  |
** work on using views for extended joins
*** update views with a trigger--see created views
**** simple update statements
***** too simple--update player_tables
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_tables SET wins = wins + 1;
#+END_SRC

#+RESULTS:
| UPDATE 8 |
|----------|
***** too complex--update player_tables
so, everytime you execute any "UPDATE player_tables", no matter what
clauses you call it with, you will actually execute the trigger
function you defined.

Compare this this statement with the one that follows it:

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_tables SET wins = wins + 1;
#+END_SRC

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from player_tables;
#+END_SRC

#+RESULTS:
| player_id | player_name | wins | losses | draws |
|-----------+-------------+------+--------+-------|
|         1 | a           |    0 |      0 |     0 |
|         2 | b           |    0 |      0 |     0 |
|         3 | c           |    0 |      0 |     0 |
|         4 | d           |    0 |      0 |     0 |
|         5 | e           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         7 | g           |    0 |      0 |     0 |
|         8 | h           |    0 |      0 |     0 |
***** most straightforward--update (reset) player_recordz directly
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET wins = 0, losses = 0, draws = 0;
select * from player_tables;
#+END_SRC

#+RESULTS:
|  UPDATE 8 |             |      |        |       |
|-----------+-------------+------+--------+-------|
| player_id | player_name | wins | losses | draws |
|         1 | a           |    0 |      0 |     0 |
|         2 | b           |    0 |      0 |     0 |
|         3 | c           |    0 |      0 |     1 |
|         4 | d           |    0 |      0 |     0 |
|         5 | e           |    0 |      0 |     0 |
|         6 | f           |    0 |      0 |     0 |
|         7 | g           |    0 |      0 |     0 |
|         8 | h           |    0 |      0 |     0 |
***** use "away victories"
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_tables
SET wins = wins + 1
from tournament_matches as a
WHERE a.home_score < a.away_score
AND a.home = player_id;

select * from player_tables
#+END_SRC

#+RESULTS:

**** create view_update_row() function
***** original
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE OR REPLACE FUNCTION view_update_row() RETURNS trigger as $view_update_row$
       BEGIN
	UPDATE player_recordz
	SET wins = wins + 1 from tournament_matches as a
	WHERE a.home_score > a.away_score
	AND a.home = player_id;
	RETURN NEW;
	END;
	$view_update_row$ LANGUAGE plpgsql;
#+END_SRC

#+RESULTS:
| CREATE FUNCTION |
|-----------------|

***** refactor to do less in the trigger
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE OR REPLACE FUNCTION view_update_row() RETURNS trigger as $view_update_row$
       BEGIN
	UPDATE player_recordz
	SET wins = wins + 1;
	RETURN NEW;
	END;
	$view_update_row$ LANGUAGE plpgsql;
#+END_SRC

#+RESULTS:
| CREATE FUNCTION |
|-----------------|

***** refactor to use conditional
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE OR REPLACE FUNCTION view_update_row() RETURNS trigger as $view_update_row$
       BEGIN
       IF a.home_score < a.away_score FROM score_results as a THEN
	UPDATE player_recordz
	SET wins = wins + 1;
	END IF;
	RETURN NEW;
	END;
	$view_update_row$ LANGUAGE plpgsql;
#+END_SRC

#+RESULTS:
| CREATE FUNCTION |
|-----------------|

**** create trigger
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE trigger view_update
INSTEAD OF UPDATE on player_tables
FOR EACH ROW
EXECUTE PROCEDURE view_update_row();

#+END_SRC

#+RESULTS:
| CREATE TRIGGER |
|----------------|

**** drop trigger (needed when tinkering with trigger)

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TRIGGER view_update on player_tables
#+END_SRC

#+RESULTS:
| DROP TRIGGER |
|--------------|


*** actually to it all without fucking any triggers

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE OR REPLACE FUNCTION view_update_row() RETURNS trigger as $view_update_row$
       BEGIN
	UPDATE player_recordz
	SET wins = wins + 1 from tournament_matches as a
	WHERE a.home_score > a.away_score
	AND a.home = player_id;
	RETURN NEW;
	END;
	$view_update_row$ LANGUAGE plpgsql;

CREATE trigger view_update
INSTEAD OF UPDATE on player_tables
FOR EACH ROW
EXECUTE PROCEDURE view_update_row();

#+END_SRC
** develop OMW
*** second round matches and scores
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO match_participants VALUES (5, 1, 5);
INSERT INTO match_participants VALUES (6, 2, 6);
INSERT INTO match_participants VALUES (7, 3, 7);
INSERT INTO match_participants VALUES (8, 4, 8);
INSERT INTO score_results VALUES (5, 10, 0);
INSERT INTO score_results VALUES (6, 10, 0);
INSERT INTO score_results VALUES (7, 0, 0);
INSERT INTO score_results VALUES (8, 1, 0);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

** work on swissPairings
*** original query
*** original query
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT a.id, a.player_name, b.id, b.player_name

FROM players as a, players as b

WHERE a.wins = b.wins

AND a.player_name != b.player_name

AND a.id < b.id
#+END_SRC
*** basic swissPairings query
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT a.player_id, b.player_id

FROM player_recordz as a, player_recordz as b

WHERE a.wins = b.wins AND a.losses = b.losses

AND a.player_id < b.player_id
#+END_SRC

#+RESULTS:
| player_id | player_id |
|-----------+-----------|
|         3 |         4 |
|         6 |         7 |
|         6 |         8 |
|         2 |         6 |
|         2 |         7 |
|         2 |         8 |
|         7 |         8 |
|         1 |         5 |

* use one org-block
** drop and create tables and views
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz CASCADE; DROP TABLE matchez CASCADE; DROP TABLE match_participants; DROP TABLE score_results; DROP TABLE player_recordz;

CREATE TABLE matchez(
       match_id serial PRIMARY KEY,
       tournament_name text not null,
       round int); 

CREATE TABLE playerz (
       player_id serial PRIMARY KEY,
       player_name text not null);

CREATE TABLE match_participants(
       match_id int REFERENCES matchez (match_id),
       home int REFERENCES playerz (player_id),
       away int REFERENCES playerz (player_id));

CREATE TABLE score_results (
       match_id int REFERENCES matchez (match_id),
       home_score int,
       away_score int);

CREATE TABLE player_recordz (
       player_id int REFERENCES playerz (player_id),
       wins int DEFAULT 0,
       losses int DEFAULT 0,
       draws int DEFAULT 0);

CREATE VIEW tournament_matches AS
select a.match_id, a.tournament_name, a.round, b.home, b.away, c.home_score, c.away_score
from matchez as a, match_participants as b, score_results as c
where a.match_id = b.match_id
AND b.match_id = c.match_id;

CREATE VIEW player_tables AS
select a.player_id, a.player_name, b.wins, b.losses, b.draws 
from playerz as a, player_recordz as b
where a.player_id = b.player_id;
#+END_SRC

#+RESULTS:
| DROP TABLE   |
|--------------|
| DROP TABLE   |
| DROP TABLE   |
| DROP TABLE   |
| DROP TABLE   |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE VIEW  |
| CREATE VIEW  |

** initialize tables
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (match_id, tournament_name, round) VALUES (1, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (2, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (3, 'tennis', 1);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (4, 'tennis', 1);


INSERT INTO playerz (player_name) VALUES ('a');
INSERT INTO playerz (player_name) VALUES ('b');
INSERT INTO playerz (player_name) VALUES ('c');
INSERT INTO playerz (player_name) VALUES ('d');
INSERT INTO playerz (player_name) VALUES ('e');
INSERT INTO playerz (player_name) VALUES ('f');
INSERT INTO playerz (player_name) VALUES ('g');
INSERT INTO playerz (player_name) VALUES ('h');

INSERT INTO player_recordz (player_id) VALUES (1);
INSERT INTO player_recordz (player_id) VALUES (2);
INSERT INTO player_recordz (player_id) VALUES (3);
INSERT INTO player_recordz (player_id) VALUES (4);
INSERT INTO player_recordz (player_id) VALUES (5);
INSERT INTO player_recordz (player_id) VALUES (6);
INSERT INTO player_recordz (player_id) VALUES (7);
INSERT INTO player_recordz (player_id) VALUES (8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

** record first round
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO match_participants VALUES (1, 1, 2);
INSERT INTO match_participants VALUES (2, 3, 4);
INSERT INTO match_participants VALUES (3, 5, 6);
INSERT INTO match_participants VALUES (4, 7, 8);

INSERT INTO score_results VALUES (1, 10, 0);
INSERT INTO score_results VALUES (2, 0, 0);
INSERT INTO score_results VALUES (3, 1, 0);
INSERT INTO score_results VALUES (4, 0, 1);
#+END_SRC


** log first round results into player records
*** all log first round stats
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT log_home_losses(1);
SELECT log_home_wins(1);
SELECT log_away_losses(1);
SELECT log_away_wins(1);
SELECT log_draws(1);
#+END_SRC

#+RESULTS:
| log_home_losses |
|-----------------|
|                 |
| log_home_wins   |
|                 |
| log_away_losses |
|                 |
| log_away_wins   |
|                 |
| log_draws       |
|                 |
*** all at once
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
UPDATE player_recordz SET losses = losses + 1
from tournament_matches as a 
WHERE a.home_score < a.away_score
AND a.home = player_id;



UPDATE player_recordz SET wins = wins + 1
from tournament_matches as a 
WHERE a.home_score > a.away_score
AND a.home = player_id;


UPDATE player_recordz SET draws = draws + 1
from tournament_matches as a 
WHERE a.home_score = a.away_score
AND (a.home = player_id OR a.away = player_id);

UPDATE player_recordz SET wins = wins + 1
from tournament_matches as a 
WHERE a.home_score < a.away_score
AND a.away = player_id;


UPDATE player_recordz SET losses = losses + 1
from tournament_matches as a 
WHERE a.home_score > a.away_score
AND a.away = player_id;
#+END_SRC
#+RESULTS:
| INSERT 0 1  |
|-------------|
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| INSERT 0 1  |
| CREATE VIEW |
| CREATE VIEW |
| UPDATE 1    |
| UPDATE 2    |
| UPDATE 2    |
| UPDATE 1    |
| UPDATE 2    |

*** individually
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- update home team losses
UPDATE player_recordz SET losses = losses + 1
from tournament_matches as a 
WHERE a.home_score < a.away_score
AND a.home = player_id;
#+END_SRC

#+RESULTS:
| UPDATE 1 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
--update home team wins
UPDATE player_recordz SET wins = wins + 1
from tournament_matches as a 
WHERE a.home_score > a.away_score
AND a.home = player_id;
#+END_SRC

#+RESULTS:
| UPDATE 2 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- update teams that drew
UPDATE player_recordz SET draws = draws + 1
from tournament_matches as a 
WHERE a.home_score = a.away_score
AND (a.home = player_id OR a.away = player_id);
#+END_SRC

#+RESULTS:
| UPDATE 2 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- update away teams that won
UPDATE player_recordz SET wins = wins + 1
from tournament_matches as a 
WHERE a.home_score < a.away_score
AND a.away = player_id;
#+END_SRC

#+RESULTS:
| UPDATE 1 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
-- update away teams that lost
UPDATE player_recordz SET losses = losses + 1
from tournament_matches as a 
WHERE a.home_score > a.away_score
AND a.away = player_id;
#+END_SRC
#+RESULTS:
| UPDATE 2 |
|----------|

*** use functions
**** log_home_losses
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE FUNCTION log_home_losses(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET losses = losses + 1
       from tournament_matches as a 
       WHERE a.home_score < a.away_score
       AND a.home = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;
#+END_SRC

#+RESULTS:
| CREATE FUNCTION |
|-----------------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice

#+END_SRC

#+RESULTS:
| log_home_losses |
|-----------------|
|                 |

**** log_home_wins()
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE FUNCTION log_home_wins(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET wins = wins + 1
       from tournament_matches as a 
       WHERE a.home_score > a.away_score
       AND a.home = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;
#+END_SRC

#+RESULTS:



#+RESULTS:
| log_away_losses |
|-----------------|
|                 |
| log_away_wins   |
|                 |
| log_draws       |
|                 |

**** log_away_losses
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE FUNCTION log_away_losses(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET losses = losses + 1
       from tournament_matches as a 
       WHERE a.home_score > a.away_score
       AND a.away = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;
#+END_SRC

#+RESULTS:
| CREATE FUNCTION |
|-----------------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice

#+END_SRC

#+RESULTS:
| log_home_losses |
|-----------------|
|                 |

**** log_away_wins
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE FUNCTION log_away_wins(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET wins = wins + 1
       from tournament_matches as a 
       WHERE a.home_score < a.away_score
       AND a.away = player_id
       AND a.round = $1;
$$ LANGUAGE SQL;
#+END_SRC

#+RESULTS:
| CREATE FUNCTION |
|-----------------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice

#+END_SRC

#+RESULTS:
| log_home_losses |
|-----------------|
|                 |

**** log_draws
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE FUNCTION log_draws(integer) RETURNS VOID AS $$
       UPDATE player_recordz SET draws = draws + 1
       from tournament_matches as a 
       WHERE a.home_score = a.away_score
       AND (a.home = player_id OR a.away = player_id)
       AND a.round = $1;
$$ LANGUAGE SQL;
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql :engine postgresql :database tourney_practice

#+END_SRC

#+RESULTS:
| log_home_losses |
|-----------------|
|                 |

** add second round data
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (match_id, tournament_name, round) VALUES (5, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (6, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (7, 'tennis', 2);
INSERT INTO matchez (match_id, tournament_name, round) VALUES (8, 'tennis', 2);
INSERT INTO match_participants VALUES (5, 1, 5);
INSERT INTO match_participants VALUES (6, 2, 6);
INSERT INTO match_participants VALUES (7, 3, 7);
INSERT INTO match_participants VALUES (8, 4, 8);
INSERT INTO score_results VALUES (5, 10, 0);
INSERT INTO score_results VALUES (6, 10, 0);
INSERT INTO score_results VALUES (7, 0, 0);
INSERT INTO score_results VALUES (8, 1, 0);

SELECT log_home_losses(2);
SELECT log_home_wins(2);
SELECT log_away_losses(2);
SELECT log_away_wins(2);
SELECT log_draws(2);
#+END_SRC
#+END_SRC

#+RESULTS:
| INSERT 0 1      |
|-----------------|
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| INSERT 0 1      |
| log_home_losses |
|                 |
| log_home_wins   |
|                 |
| log_away_losses |
|                 |
| log_away_wins   |
|                 |
| log_draws       |
|                 |



* check on all tables and views
** plain tables
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from matchez;
select * from playerz;
select * from match_participants;
select * from score_results;
#+END_SRC


#+RESULTS:
|  match_id | tournament_name |            |       |
|-----------+-----------------+------------+-------|
|         1 |          tennis |            |       |
|         2 |          tennis |            |       |
|         3 |          tennis |            |       |
|         4 |          tennis |            |       |
|         5 |          tennis |            |       |
|         6 |          tennis |            |       |
|         7 |          tennis |            |       |
|         8 |          tennis |            |       |
| player_id |     player_name |            |       |
|         1 |               a |            |       |
|         2 |               b |            |       |
|         3 |               c |            |       |
|         4 |               d |            |       |
|         5 |               e |            |       |
|         6 |               f |            |       |
|         7 |               g |            |       |
|         8 |               h |            |       |
|  match_id |            home |       away |       |
|         1 |               1 |          2 |       |
|         2 |               3 |          4 |       |
|         3 |               5 |          6 |       |
|         4 |               7 |          8 |       |
|         5 |               1 |          5 |       |
|         6 |               2 |          6 |       |
|         7 |               3 |          7 |       |
|         8 |               4 |          8 |       |
|  match_id |      home_score | away_score |       |
|         1 |              10 |          0 |       |
|         2 |               0 |          0 |       |
|         3 |               1 |          0 |       |
|         4 |               0 |          1 |       |
|         5 |              10 |          0 |       |
|         6 |              10 |          0 |       |
|         7 |               0 |          0 |       |
|         8 |               1 |          0 |       |
| player_id |            wins |     losses | draws |
|         1 |               1 |          0 |     0 |
|         5 |               1 |          0 |     0 |
|         3 |               0 |          0 |     1 |
|         4 |               0 |          0 |     1 |
|         8 |               1 |          0 |     0 |
|         2 |               0 |          1 |     0 |
|         6 |               0 |          1 |     0 |
|         7 |               0 |          2 |     0 |

** two views
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from tournament_matches;
#+END_SRC

#+RESULTS:
| match_id | tournament_name | round | home | away | home_score | away_score |
|----------+-----------------+-------+------+------+------------+------------|
|        1 | tennis          |     1 |    1 |    2 |         10 |          0 |
|        2 | tennis          |     1 |    3 |    4 |          0 |          0 |
|        3 | tennis          |     1 |    5 |    6 |          1 |          0 |
|        4 | tennis          |     1 |    7 |    8 |          0 |          1 |
|        5 | tennis          |     2 |    1 |    5 |         10 |          0 |
|        6 | tennis          |     2 |    2 |    6 |         10 |          0 |
|        7 | tennis          |     2 |    3 |    7 |          0 |          0 |
|        8 | tennis          |     2 |    4 |    8 |          1 |          0 |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from player_tables;
#+END_SRC

#+RESULTS:
| player_id | player_name | wins | losses | draws |
|-----------+-------------+------+--------+-------|
|         1 | a           |    2 |      0 |     0 |
|         2 | b           |    1 |      1 |     0 |
|         4 | d           |    1 |      0 |     1 |
|         5 | e           |    1 |      1 |     0 |
|         6 | f           |    0 |      2 |     0 |
|         8 | h           |    1 |      1 |     0 |
|         7 | g           |    0 |      1 |     1 |
|         3 | c           |    0 |      0 |     2 |
** view provisional pairings
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
SELECT a.player_id, a.wins, a.losses, a.draws, b.player_id, b.wins, b.losses, b.draws

FROM player_recordz as a, player_recordz as b

WHERE a.wins = b.wins AND a.losses = b.losses 

AND a.player_id < b.player_id
#+END_SRC  

#+RESULTS:
| player_id | wins | losses | draws | player_id | wins | losses | draws |
|-----------+------+--------+-------+-----------+------+--------+-------|
|         5 |    1 |      1 |     0 |         8 |    1 |      1 |     0 |
|         2 |    1 |      1 |     0 |         5 |    1 |      1 |     0 |
|         2 |    1 |      1 |     0 |         8 |    1 |      1 |     0 |

