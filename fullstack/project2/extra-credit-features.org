* extra credit features
** Prevent rematches between players.
*** natural planning
So basically, 

1. register some number of players greater than 4
   - work off an existing round number type of tournament
2. report an intial set of victories with reportMatches
   - plan how to set up the first batch of matches
     - 1 d. 2
     - 3 d. 4
     - etc.
3. tinker with swissPairings
   - add a clause that looks at entries in matches
4. use tourney_practice to experiment with the correct raw SQL 

|                    | "Twilight Sparkle" | "Fluttershy" | "Applejack" | "Pinkie Pie" | "Bruno Walton" | "Boots O'Neal" | "Cathy Burton" | "Diane Grant" |
|--------------------+--------------------+--------------+-------------+--------------+----------------+----------------+----------------+---------------|
| "Twilight Sparkle" | nil                |              |             |              |                |                |                |               |
| "Fluttershy"       |                    |              |             |              |                |                |                |               |
| "Applejack"        |                    |              |             |              |                |                |                |               |
| "Pinkie Pie"       |                    |              |             |              |                |                |                |               |
| "Bruno Walton"     |                    |              |             |              |                |                |                |               |
| "Boots O'Neal"     |                    |              |             |              |                |                |                |               |
| "Cathy Burton"     |                    |              |             |              |                |                |                |               |
| "Diane Grant"      |                    |              |             |              |                |                |                |               |
*** 4 abcd
| match no. | winner | loser |
|-----------+--------+-------|
|         1 | a      | b     |
|         2 | c      | d     |
|-----------+--------+-------|
|         3 | a      | c     |
|         4 | b      | d     |
|         5 |        |       |
|         6 |        |       |
|         7 |        |       |
|         8 |        |       |
|         9 |        |       |
|        10 |        |       |
|        11 |        |       |
|        12 |        |       |
|        13 |        |       |
|        14 |        |       |
|        15 |        |       |
|        16 |        |       |
*** 8 abcdefgh
| match no. | winner | loser | win_id | lose_id | winner record | loser record |
|-----------+--------+-------+--------+---------+---------------+--------------|
|         1 | a      | b     |      1 |       2 |           0-0 |          0-0 |
|         2 | c      | d     |      3 |       4 |           0-0 |          0-0 |
|         3 | e      | f     |      5 |       6 |           0-0 |          0-0 |
|         4 | g      | h     |      7 |       8 |           0-0 |          0-0 |
|-----------+--------+-------+--------+---------+---------------+--------------|
|         5 | a      | c     |      1 |       3 |           1-0 |          1-0 |
|         6 | e      | g     |      5 |       7 |           1-0 |          1-0 |
|         7 | b      | d     |      2 |       4 |           0-1 |          0-1 |
|         8 | f      | h     |      6 |       8 |           0-1 |          0-1 |
|-----------+--------+-------+--------+---------+---------------+--------------|
|         9 | a      | e     |      1 |       5 |           2-0 |          2-0 |
|        10 | b      | c     |      2 |       3 |           1-1 |          1-1 |
|        11 | f      | g     |      6 |       7 |           1-1 |          1-1 |
|        12 | d      | h     |      4 |       8 |           0-2 |          0-2 |
|-----------+--------+-------+--------+---------+---------------+--------------|


| team | wins | losses | avg. wins of teams lost to |   |
|------+------+--------+----------------------------+---|
| a    |    3 |      0 |                          - |   |
| b    |    2 |      1 |                          3 |   |
| f    |    2 |      1 |                          1 |   |
| c    |    1 |      2 |                            |   |
| d    |    1 |      2 |                            |   |
| e    |    1 |      2 |                            |   |
| g    |    1 |      2 |                            |   |
| h    |    0 |      3 |                            |   |

*** 16 players
a. 
b. 
c. 
d. 
e. 
f. 
g. 
h. 

i. 
j. 
k. 
l. 
m. 
n. 
o. 
p. 

*** number pairs to return!
    "For four players, swissPairings should return two pairs."
For eight players, what number of pairs to return?
Well, you'd need to report an initial group of 4 matches.

So, whereas the test for the meets specifications starts off so:

#+BEGIN_SRC python
registerPlayer("Twilight Sparkle")
    registerPlayer("Fluttershy")
    registerPlayer("Applejack")
    registerPlayer("Pinkie Pie")
    standings = playerStandings()
    [id1, id2, id3, id4] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
#+END_SRC

We would instead do something like

#+BEGIN_SRC python
registerPlayer("Twilight Sparkle")
registerPlayer("Fluttershy")
registerPlayer("Applejack")
registerPlayer("Pinkie Pie")

    registerPlayer("Bruno Walton")
    registerPlayer("Boots O'Neal")
    registerPlayer("Cathy Burton")
    registerPlayer("Diane Grant")

    standings = playerStandings()
    [id1, id2, id3, id4, id5, id6, id7, id8] = [row[0] for row in standings]
    reportMatch(id1, id2)
    reportMatch(id3, id4)
    reportMatch(id5, id6)
    reportMatch(id7, id8)
#+END_SRC
** odd number of players requires a bye
 Don’t assume an even number of players. If there is an odd number of
 players, assign one player a “bye” (skipped round). A bye counts as a
 free win. A player should not receive more than one bye in a
 tournament.
** allow ties
 Support games where a draw (tied game) is possible. This will require
 changing the arguments to reportMatch.
** use Opponent Match Wins as criteria for breaking ties in ranking
 When two players have the same number of wins, rank them according to
 OMW (Opponent Match Wins), the total number of wins by players they
 have played against.
**  Support more than one tournament in the database
 Support more than one tournament in the database, so matches do not
 have to be deleted between tournaments. This will require
 distinguishing between “a registered player” and “a player who has
 entered in tournament #123”, so it will require changes to the
 database schema.
** You may refer to outside resources to devise your pairing algorithm.
Wizards of the Coast has prepared simple instructions, and more
details can be found in resources linked to in the reference section
of Wikipedia's article on Swiss tournaments.

* Python code that passes basic tests
**  connect():
*** original, with 'tournament' as dbname
#+BEGIN_SRC python :session *Python* :results output
import psycopg2


def connect():
    """Connect to the PostgreSQL database.  Returns a database connection."""
    return psycopg2.connect("dbname=tournament")

#+END_SRC

#+RESULTS:

*** original, with 'tourney_practice' as dbname
#+BEGIN_SRC python :session *Python* :results output
import psycopg2


def connect():
    """Connect to the PostgreSQL database.  Returns a database connection."""
    return psycopg2.connect("dbname=tourney_practice")

#+END_SRC

#+RESULTS:

*** refactor 'connect' to take a dbname argument
#+BEGIN_SRC python :session *Python* :results output
import psycopg2

def new_connect(dbname):
    """Connect to the PostgreSQL database.  Returns a database connection."""
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)

#+END_SRC

#+RESULTS:
**  dbExecuteWrapper(query_string, extra=None):
*** original
'extra' parameter gets used when calling an INSERT query 
#+BEGIN_SRC python :session *Python* :results output

# refactor to use connect() for final version
def dbExecuteWrapper(query_string, extra=None):
    DB = connect()
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC


*** refactor for varying databases
#+BEGIN_SRC python :session *Python* :results output

# refactor to use connect() for final version
def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC

#+RESULTS:

*** use new_dbExecuteWrapper with new_connect and tourney_practice
#+BEGIN_SRC python :session *Python* :results output
new_dbExecuteWrapper(
#+END_SRC
**  dbExecuteRetrievalWrapper_allrows(query_string):
*** original
doesn't work as a babel block without 'return' statement last
#+BEGIN_SRC python :session *Python* :results output

def dbExecuteRetrievalWrapper_allrows(query_string):
    DB = connect()
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()
    return rows

#+END_SRC

#+RESULTS:
*** example of original


#+BEGIN_SRC python :session *Python* :results output
dbExecuteRetrievalWrapper_allrows("select * from players2")
#+END_SRC

#+RESULTS:
: [(218, 'Fluttershy', 0, 1), (217, 'Twilight Sparkle', 1, 1), (220, 'Pinkie Pie', 0, 1), (219, 'Applejack', 1, 1)]

**  deleteMatches():
*** original
#+BEGIN_SRC python :session *Python* :results output
# refactor all queries into a variable that is then passed to execute

def deleteMatches():
    query = """DELETE FROM matches;"""
    dbExecuteWrapper(query)

#+END_SRC
*** refactor to vary databases and tables
#+BEGIN_SRC python :session *Python* :results output
# refactor all queries into a variable that is then passed to execute

def new_deleteTable(dbname, table_name):
    query = """DELETE FROM (%s);"""
    dbExecuteWrapper(query, dbname, (table_name,))

#+END_SRC

#+RESULTS:

*** call delete with "tourney_practice" arguments
#+BEGIN_SRC python :session *Python* :results output
deleteTable(tourney_practice, matches2)
#+END_SRC
**  deletePlayers():
*** original
#+BEGIN_SRC python :session *Python* :results output
def deletePlayers():
    query = """DELETE FROM players;"""
    dbExecuteWrapper(query)

#+END_SRC
*** refactor to take a table name as argument
#+BEGIN_SRC python :session *Python* :results output
def deletePlayers():
    query = """DELETE FROM players;"""
    dbExecuteWrapper(query)

#+END_SRC
**  countPlayers():
*** original
#+BEGIN_SRC python :session *Python* :results output
def countPlayers():
    DB = connect()
    c = DB.cursor()
    query = "SELECT count(*) FROM players;"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    return int(row_item[0])
    DB.close()

#+END_SRC
**  registerPlayer(name):
*** original
# Some kind of problem using _allrows with multiline string formatting

#+BEGIN_SRC python :session *Python* :results output
def registerPlayer(name):
    query = ("INSERT INTO players (player_name, wins, matches)"
             "VALUES (%s, %s, %s);")
    dbExecuteWrapper(query, (name, 0, 0))
#+END_SRC

*** define registerPlayer with players2 as table 
#+BEGIN_SRC python :session *Python* :results output
def registerPlayer(name):
    query = ("INSERT INTO players2 (player_name, wins, matches)"
             "VALUES (%s, %s, %s);")
    dbExecuteWrapper(query, (name, 0, 0))


# Some kind of problem using _allrows with multiline string formatting
#+END_SRC

*** register some players
#+BEGIN_SRC python :session *Python* :results output
registerPlayer("A")
registerPlayer("B")
registerPlayer("C")
registerPlayer("D")
registerPlayer("E")
registerPlayer("F")
registerPlayer("G")
registerPlayer("H")
registerPlayer("I")
registerPlayer("J")
registerPlayer("K")
registerPlayer("L")
registerPlayer("M")
registerPlayer("N")
registerPlayer("O")
registerPlayer("P")
#+END_SRC

#+RESULTS:

*** register some players with table playerz
#+BEGIN_SRC python :session *Python* :results output
new_registerPlayer("A", "playerz")
new_registerPlayer("B", "playerz")
new_registerPlayer("C", "playerz")
new_registerPlayer("D", "playerz")
new_registerPlayer("E", "playerz")
new_registerPlayer("F", "playerz")
new_registerPlayer("G", "playerz")
new_registerPlayer("H", "playerz")
new_registerPlayer("I", "playerz")
new_registerPlayer("J", "playerz")
new_registerPlayer("K", "playerz")
new_registerPlayer("L", "playerz")
new_registerPlayer("M", "playerz")
new_registerPlayer("N", "playerz")
new_registerPlayer("O", "playerz")
new_registerPlayer("P", "playerz")
#+END_SRC

**  playerStandings():
#+BEGIN_SRC python :session *Python* :results output
def playerStandings():
    query = ("SELECT id, player_name, wins, matches "
             "FROM players ORDER BY wins DESC;")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC
**  reportMatch(winner, loser):
#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    query1 = ("INSERT INTO matches VALUES (%s, %s) ;")
    query2 = ("UPDATE players SET wins = wins + 1"
              "FROM matches WHERE players.id = (%s) ;")
    query3 = ("UPDATE players SET matches = matches + 1"
              "FROM matches WHERE players.id = (%s) OR players.id = (%s);")
    dbExecuteWrapper(query1, (winner, loser))
    dbExecuteWrapper(query2, (winner,))
    dbExecuteWrapper(query3, (winner, loser))

#+END_SRC

**  swissPairings():
#+BEGIN_SRC python :session *Python* :results output
def swissPairings():
    query = ("SELECT a.id, a.player_name, b.id, b.player_name "
             "FROM players as a, players as b "
             "WHERE a.wins = b.wins "
             "AND a.player_name != b.player_name "
             "AND a.id < b.id")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC
* new_ suite of functions--create, update, delete--using wrapper function
** start here this works
*** import psycopg and define a db-agnostic connect function
**** def new_connect(dbname):						:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
import psycopg2

def new_connect(dbname):
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)
#+END_SRC
*** define a db-agnostic execute wrapper
**** def new_dbExecuteWrapper(query_string, dbname, extra=None):	:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()
#+END_SRC
*** define a db-agnostic retrieval wrapper
**** def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):	:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()    
    return rows

#+END_SRC

#+RESULTS:

*** define a db and table-agnostic deleteTable function
**** def new_deleteTable(dbname, table_name):				:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_deleteTable(dbname, table_name):
    tb_name = table_name
    sql_keywords = """DELETE FROM """
    query = sql_keywords + tb_name
    table_nm = (table_name,)
    new_dbExecuteWrapper(query, dbname)
#+END_SRC

#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "matchez")
#+END_SRC    

#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "playerz")
#+END_SRC    

#+RESULTS:

*** use new_deleteTable to define deleteMatches and deletePlayers function
**** deleteTable matchez and playerz
#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "matchez")
#+END_SRC    

#+BEGIN_SRC python :session *Python* :results output
new_deleteTable("tourney_practice", "playerz")
#+END_SRC    
*** countPlayers
**** refactor to take table name as argument--must return as last line?
#+BEGIN_SRC python :session *Python* :results output
def countPlayers():
    DB = connect()
    c = DB.cursor()
    query = "SELECT count(*) FROM players;"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    return int(row_item[0])
    DB.close()

#+END_SRC
**** def new_countPlayers(dbname, table_name):				:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_countPlayers(dbname, table_name):
    DB = new_connect(dbname)
    c = DB.cursor()
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT count(*)" + from_statement + ";"
    c.execute(query)
    row = c.fetchone()
    row_item = list(row)
    DB.close()
    return int(row_item[0])


#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
new_countPlayers("tourney_practice", "playerz")
#+END_SRC

#+RESULTS:
: 3

*** refactor registerPlayer to take a table_name argument
**** assumes columns have certain hard-coded names
#+BEGIN_SRC python :session *Python* :results output
def new_registerPlayer(dbname, table_name, player_name):
    tb_name = table_name
    sql_keywords = """INSERT INTO """
    insert_statement = sql_keywords + tb_name
    query = (insert_statement + "(player_name, wins, matchez)"
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, 0, 0))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :session *Python* :results output
new_registerPlayer("tourney_practice", "playerz", "CCCC")
#+END_SRC

#+RESULTS:
**** make a general INSERT statement string generator
#+BEGIN_SRC python :session *Python* :results value
def insert_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """INSERT INTO """
    insert_statement = sql_keywords + tb_name
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results value
insert_statement_string("matchez")
#+END_SRC

#+RESULTS:

**** make a general UPDATE statement string generator
#+BEGIN_SRC python :session *Python* :results output
def update_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """UPDATE """
    update_statement = sql_keywords + tb_name
#+END_SRC
**** make a general SQL KEYWORD + tablename statement string generator	
**** def keyword_statement_string(table_name, sql_keyword):		:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def keyword_statement_string(table_name, sql_keyword):
    tb_name = table_name
    sql_keywords = sql_keyword + """ """
    update_statement = sql_keywords + tb_name + """ """
    return update_statement
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
keyword_statement_string("matchez", "FROM")
#+END_SRC

#+RESULTS:
: 'FROM matchez '

**** def new_registerPlayer(dbname, table_name, player_name):		:def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_registerPlayer(dbname, table_name, player_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name, wins, matchez)" + 
             "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, 0, 0))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
new_registerPlayer("tourney_practice", "playerz", "AAAA")
new_registerPlayer("tourney_practice", "playerz", "BBBB")
new_registerPlayer("tourney_practice", "playerz", "CCCC")
new_registerPlayer("tourney_practice", "playerz", "DDDD")
#+END_SRC

#+RESULTS:

*** refactor playerStandings
**** def new_playerStandings(table_name)--assumes columns with hard-coded names :def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_playerStandings(table_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = ("SELECT id, player_name, wins, matchez " +
             from_statement + "ORDER BY wins DESC;")
    return new_dbExecuteRetrievalWrapper_allrows("tourney_practice", query)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session *Python* :results output
new_playerStandings("playerz")
#+END_SRC

#+RESULTS:
: [(1, 'AAAA', 1, 1), (2, 'BBBB', 0, 1), (3, 'CCCC', 0, 0)]
*** refactor reportMatch(winner, loser):
**** original contains matches and players table names
#+BEGIN_SRC python :session *Python* :results output
def reportMatch(winner, loser):
    query1 = ("INSERT INTO matches VALUES (%s, %s) ;")
    query2 = ("UPDATE players SET wins = wins + 1"
              "FROM matches WHERE players.id = (%s) ;")
    query3 = ("UPDATE players SET matches = matches + 1"
              "FROM matches WHERE players.id = (%s) OR players.id = (%s);")
    dbExecuteWrapper(query1, (winner, loser))
    dbExecuteWrapper(query2, (winner,))
    dbExecuteWrapper(query3, (winner, loser))

#+END_SRC
**** def new_reportMatch(dbname, table1, table2, winner, loser)--still hard codes column names :def:
#+BEGIN_SRC python :session *Python* :results output :tangle yes
def new_reportMatch(dbname, table1, table2, winner, loser):
    q1_insert = keyword_statement_string(table2, """INSERT INTO""")
    q2_update = keyword_statement_string(table1, """UPDATE""")
    q2_from = keyword_statement_string(table2, """FROM""")
    query1 = (q1_insert + "VALUES (%s, %s) ;")
    query2 = (q2_update + "SET wins = wins + 1" + 
              q2_from + "WHERE playerz.id = (%s);")
    query3 = (q2_update + "SET matchez = matchez + 1" + 
              q2_from + "WHERE playerz.id = (%s) OR playerz.id = (%s);")
    new_dbExecuteWrapper(query1, dbname, (winner, loser))
    new_dbExecuteWrapper(query2, dbname, (winner,))
    new_dbExecuteWrapper(query3, dbname, (winner, loser))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :session *Python* :results output
new_reportMatch("tourney_practice", "playerz", "matchez", 1, 2)
#+END_SRC

#+RESULTS:


*** swissPairings() will require more clauses?
#+BEGIN_SRC python :session *Python* :results output
def swissPairings():
    query = ("SELECT a.id, a.player_name, b.id, b.player_name "
             "FROM players as a, players as b "
             "WHERE a.wins = b.wins "
             "AND a.player_name != b.player_name "
             "AND a.id < b.id")
    return dbExecuteRetrievalWrapper_allrows(query)

#+END_SRC
** steps and code
*** steps
1. drop tables
2. redefine tablez for tourney_practice with sql statements
3. create players using bare sql in CLI
4. delete matches first function
   - using deleteTable function that takes a table name to delete all
     rows from
   - got stuck on imitating passing VALUES () sql syntax i.e. adding
     parens where unnecessary in a straight DELETE FROM statement
   - trouble using new_deleteTable that takes a db name as well, as a tablename
     - [[*define new deleteTable that takes a database name as well][define new deleteTable that takes a database name as well]]
     - syntax error: LINE 1: DELETE FROM 'matchez';
       - why is the argument getting passed with single-quotes
       - i.e. of the two following code blocks, the first doesn't
         work, while the second does
5. delete anything using new_dbexecuteWrapper
   - test out new_connect
     - in order to test new_connect using a delete, need to register
       players and report matches between them
       - where is this done?
	 - DROP matchez and playerz tables; then create new with bare SQL
	 - check from psql SELECT *
	 - INSERT INTO playerz from psql
	 - use reportMatch_tourney(1, 2) as above
	   - [[*call reportMatch_tourney][call reportMatch_tourney]]
	   - check from psql SELECT *
6. refactor reportMatches to take db, and two table names
   - still contains hard-coded references to column names
7. refactor registerPlayer to take db, table name

* planning steps toward implementing OMW
** 1. clear tourney practice of playerz and matchez tables 
*** do this from org-babel
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz; DROP TABLE matchez;
#+END_SRC

#+RESULTS:
| DROP TABLE |
|------------|
| DROP TABLE |
*** check that you have emptied
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from playerz;
#+END_SRC

#+RESULTS:




| id | player_name | wins | matchez | omw |
|----+-------------+------+---------+-----|
|  1 | a           |    0 |       0 |   0 |
|  2 | b           |    0 |       0 |   0 |
|  3 | c           |    0 |       0 |   0 |
|  4 | d           |    0 |       0 |   0 |
|  5 | e           |    0 |       0 |   0 |
|  6 | f           |    0 |       0 |   0 |
|  7 | g           |    0 |       0 |   0 |
|  8 | h           |    0 |       0 |   0 |

** 2. setup tables
*** simple version for basic credit
#+BEGIN_SRC sql
CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer); CREATE TABLE matchez(winner integer, loser integer);
#+END_SRC
*** extended version for extra credit
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer, OMW integer); CREATE TABLE matchez(match_id serial, winner integer, loser integer); 
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|
| CREATE TABLE |

** 3. register some players
*** original version where playerz have a 'name', wins and matches
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name, wins, matchez) VALUES ('a', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('b', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('c', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('d', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('e', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('f', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('g', 0, 0);
INSERT INTO playerz (player_name, wins, matchez) VALUES ('h', 0, 0);
#+END_SRC
*** INSERT players into playerz but provide an 'opponent matches wins' argument
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('a', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('b', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('c', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('d', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('e', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('f', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('g', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('h', 0, 0, 0);
#+END_SRC

** 4. make a query to update OMW when a Match is reported
*** use update playerz 
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 from matchez where playerz.id = matchez.loser;
#+END_SRC
** 5. report some Matches to start building new functionality
- many sub steps to reporting Matches functionality
- ultimately will need an autoincrementing matchID column to
  distinguish matches and rounds

*** round 1 interactions
**** reportMatches using SQL
***** insert four round 1 matches
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 2);
INSERT INTO matchez (winner, loser) VALUES (3, 4);
INSERT INTO matchez (winner, loser) VALUES (5, 6);
INSERT INTO matchez (winner, loser) VALUES (7, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

***** after round1 all swissPairings will be:

#+RESULTS:
| id | player_name | id | player_name |
|----+-------------+----+-------------|
|  2 | b           |  8 | h           |
|  2 | b           |  4 | d           |
|  2 | b           |  6 | f           |
|  4 | d           |  8 | h           |
|  4 | d           |  6 | f           |
|  6 | f           |  8 | h           |
|  1 | a           |  3 | c           |
|  1 | a           |  5 | e           |
|  1 | a           |  7 | g           |
|  3 | c           |  5 | e           |
|  3 | c           |  7 | g           |
|  5 | e           |  7 | g           |
**** update players wins after first round
***** update just player 1 wins after first round
update the wins of players with an id in the 'winner' column

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5;
#+END_SRC
***** second round (match ids 5-9) update all winners
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 4 AND matchez.match_id < 9;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|

***** long, hard-coded approach in SQL
Is there a way in a query to not have to specify the exact player id,
but instead to use the id of anyone whose id appears in the winner column?
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = 3;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 5;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 7;
#+END_SRC

#+RESULTS:
| UPDATE 1 |
|----------|
| UPDATE 1 |
| UPDATE 1 |

All at once
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = 1;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 3;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 5;
update playerz set wins = wins + 1 FROM matchez where playerz.id = 7;
#+END_SRC

**** increment OMW for first round losers
***** long, hard-coded approach in SQL
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 2;
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 4;
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 6;
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = 8;
#+END_SRC

#+RESULTS:
| UPDATE 1 |
|----------|
| UPDATE 1 |
| UPDATE 1 |
| UPDATE 1 |
***** update OMW using match_ids
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|
***** rethink OMW to use averaging?
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = sum(playerz.wins) FROM matchez where playerz.id = 
#+END_SRC

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select player_name
#+END_SRC
use new table for each player--opponents?
**** add a match to everyplayer--use after a full set of matches reported
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
#+END_SRC

#+RESULTS:
| UPDATE 8 |
|----------|

*** after round 2
**** insert round 2 results such that 'a' will play 'e' in the final
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3);
INSERT INTO matchez (winner, loser) VALUES (5, 7);
INSERT INTO matchez (winner, loser) VALUES (2, 4);
INSERT INTO matchez (winner, loser) VALUES (6, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

have to use results from swiss pairings
** select * playerz
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from playerz;
#+END_SRC

#+RESULTS:
| id | player_name | wins | matchez | omw |
|----+-------------+------+---------+-----|
|  2 | b           |    0 |       0 |   0 |
|  4 | d           |    0 |       0 |   0 |
|  6 | f           |    0 |       0 |   0 |
|  8 | h           |    0 |       0 |   0 |
|  1 | a           |    1 |       0 |   0 |
|  3 | c           |    1 |       0 |   0 |
|  5 | e           |    1 |       0 |   0 |
|  7 | g           |    1 |       0 |   0 |

** select all matchez
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
select * from matchez
#+END_SRC

#+RESULTS:
| winner | loser |
|--------+-------|
|      1 |     2 |
|      3 |     4 |
|      5 |     6 |
|      7 |     8 |

* sequence of SQL commands
** master list
*** clear and setup and insert players
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz; DROP TABLE matchez; CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer, OMW integer); CREATE TABLE matchez(match_id serial, winner integer, loser integer); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('a', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('b', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('c', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('d', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('e', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('f', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('g', 0, 0, 0); INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('h', 0, 0, 0); 
#+END_SRC

#+RESULTS:
| DROP TABLE   |
|--------------|
| DROP TABLE   |
| CREATE TABLE |
| CREATE TABLE |
| INSERT 0 1   |
| INSERT 0 1   |
| INSERT 0 1   |
| INSERT 0 1   |
| INSERT 0 1   |
| INSERT 0 1   |
| INSERT 0 1   |
| INSERT 0 1   |
*** insert winner-loser pairs for first round; update wins, OMW, matches
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 2); INSERT INTO matchez (winner, loser) VALUES (3, 4); INSERT INTO matchez (winner, loser) VALUES (5, 6); INSERT INTO matchez (winner, loser) VALUES (7, 8); update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5; update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5; update playerz set matchez = matchez + 1;
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| UPDATE 4   |
| UPDATE 4   |
| UPDATE 8   |
*** insert second winner-loser pairs such that: 'a' will play 'e' in the final
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3); INSERT INTO matchez (winner, loser) VALUES (5, 7); INSERT INTO matchez (winner, loser) VALUES (2, 4); INSERT INTO matchez (winner, loser) VALUES (6, 8);  update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 4 AND matchez.match_id < 9; update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 4 AND matchez.match_id < 9; update playerz set matchez = matchez + 1;
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| UPDATE 4   |
| UPDATE 4   |
| UPDATE 8   |

** 1. clear and setup tables again
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
DROP TABLE playerz; DROP TABLE matchez;
#+END_SRC

#+RESULTS:
| DROP TABLE |
|------------|
| DROP TABLE |

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
CREATE TABLE playerz(id serial PRIMARY KEY, player_name text not null, wins integer, matchez integer, OMW integer); CREATE TABLE matchez(match_id serial, winner integer, loser integer); update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5; update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5; update playerz set matchez = matchez + 1;
#+END_SRC

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3); INSERT INTO matchez (winner, loser) VALUES (5, 7); INSERT INTO matchez (winner, loser) VALUES (2, 4); INSERT INTO matchez (winner, loser) VALUES (6, 8); 

#+END_SRC
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5;
#+END_SRC
#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

** 2. insert players into players table
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('a', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('b', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('c', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('d', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('e', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('f', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('g', 0, 0, 0);
INSERT INTO playerz (player_name, wins, matchez, OMW) VALUES ('h', 0, 0, 0);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

** 3. insert first winner-loser pairs into matches table
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 2);
INSERT INTO matchez (winner, loser) VALUES (3, 4);
INSERT INTO matchez (winner, loser) VALUES (5, 6);
INSERT INTO matchez (winner, loser) VALUES (7, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

** 4. update 'wins', 'OMW', and 'matches' for the affected players
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id < 5;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id < 5;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1;
#+END_SRC

#+RESULTS:
| UPDATE 8 |
|----------|

** 5. insert second winner-loser pairs into matches table
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 3);
INSERT INTO matchez (winner, loser) VALUES (5, 7);
INSERT INTO matchez (winner, loser) VALUES (2, 4);
INSERT INTO matchez (winner, loser) VALUES (6, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

** 6. REPEAT 4--update 'wins', 'OMW', and 'matches' for the affected players
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 4 and matchez.match_id < 9;
#+END_SRC

#+RESULTS:
| UPDATE 3 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 4 and matchez.match_id < 9;
#+END_SRC

#+RESULTS:
| UPDATE 3 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
#+END_SRC

#+RESULTS:
| UPDATE 8 |
|----------|

** 7. insert third winner-loser pairs, a-e championship
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
INSERT INTO matchez (winner, loser) VALUES (1, 5); INSERT INTO matchez (winner, loser) VALUES (2, 6); INSERT INTO matchez (winner, loser) VALUES (3, 7); INSERT INTO matchez (winner, loser) VALUES (4, 8);
#+END_SRC

#+RESULTS:
| INSERT 0 1 |
|------------|
| INSERT 0 1 |
| INSERT 0 1 |
| INSERT 0 1 |

** 9. REPEAT 4--update 'wins', 'OMW', and 'matches' for the affected players
#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set wins = wins + 1 FROM matchez where playerz.id = matchez.winner AND matchez.match_id > 8 and matchez.match_id < 13;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set OMW = OMW + 1 FROM matchez where playerz.id = matchez.loser AND matchez.match_id > 8 and matchez.match_id < 13;
#+END_SRC

#+RESULTS:
| UPDATE 4 |
|----------|

#+BEGIN_SRC sql :engine postgresql :database tourney_practice
update playerz set matchez = matchez + 1
#+END_SRC

#+RESULTS:
| UPDATE 8 |
|----------|
