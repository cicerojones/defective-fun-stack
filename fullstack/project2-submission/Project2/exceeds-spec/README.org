* Project 2 ("Tournament Results") EXCEEDS SPECIFICATIONS code overview
This README primarily provides a description of three files:

- core/final_project.py
- core/tournament.sql
- core/tournament_demonstration.py


** Meeting and Exceeding Specifications
In the [[file:../meets-spec/README.org][readme]] for "meets specs," I have described a basic outline of
what the code there does in order to "meet specifications." Though all
of that basic functionality is provided by the ~exceed spec~ code in
this directory as well, new functions were written that extend and
supersede that basic functionality (of course, code that was not
present in the "meets specs" code base was needed to provide the
"exceeds spec" features).

Additionally, I provide some basic documentation description of the
postgresql database schema, which features extensive use of
psql-specific functionality, including psql functions, views, triggers
etc.

** Description of extra credit features
What follows is a description of three features that the "exceeds
specs" code base provides.
*** /allow ties/ feature
 Support games where a draw (tied game) is possible. This will require
 changing the arguments to reportMatch.
*** /use Opponent Match Wins as criteria for breaking ties in ranking/
When two players have the same number of wins, rank them according to
OMW (Opponent Match Wins), the total number of wins by players they
have played against.
*** /Support more than one tournament in the database/
Support more than one tournament in the database, so matches do not
have to be deleted between tournaments. This will require
distinguishing between “a registered player” and “a player who has
entered in tournament #123”, so it will require changes to the
database schema.
** Code and Specs
*** original 'final_project.py' (meets)

~final_project.py~ provides several Python functions that allow the
user to interact with a PostgreSQL database from Python.

Specifically, the user can 

- /register players/ for a tournament by adding them to an SQL database
- /delete players/ from the database
- /log matches/ between players, registering a winner and a loser
- /delete matches/ from the database
- /create statistics/ from the database, such as "number of players"
  and "player standings"
- /determine match pairings/ for additional rounds of a tournament,
  based on the player standings

This functionality is provided by the following functions:
- =deleteMatches()=
- =deletePlayers()=
- =countPlayers()=
- =registerPlayer()=
- =playerStandings()=
- =reportMatch()=
- =swissPairings()=

In addition to these core functions, there are three functions
intended to abstract out some of the details of commonly occuring
database interactions:

- /provide a database connection/ to the main postgres db used in this
  module
- /modify a table/ in the database
- /retrieve some data/ from the database

This functionality, which was not called for by the design
specifications but seemed helpful nonetheless, is provided by the
following functions:

- =connect()=
- =dbExecuteWrapper()=
- =dbExecuteRetrievalWrapper_allrows()=
*** code stubs in exceeds version of 'final_project.py'
**** shared in concept with 'meets' code
***** delete tables
 #+BEGIN_SRC python
 def new_deleteTable(dbname, table_name):
 #+END_SRC

***** count Players
 #+BEGIN_SRC python
 def new_countPlayers(dbname, table_name):
 #+END_SRC

***** register Players
 #+BEGIN_SRC python
 def new_registerPlayer(dbname, table_name, player_name, tournament_name):
 #+END_SRC

***** player Standings
 #+BEGIN_SRC python
 def new_playerStandings(dbname, table_name):
 #+END_SRC

***** register Matches
 #+BEGIN_SRC python
 def registerMatch(dbname, table_name, tournament_name, round_of_tournament):
 #+END_SRC

**** new helper functions
#+BEGIN_SRC python 
def update_statement_string(table_name):
#+END_SRC

#+BEGIN_SRC python
def keyword_statement_string(table_name, sql_keyword):
#+END_SRC
**** entirely new functions for 'exceeds specs'

***** register Match Participants
 #+BEGIN_SRC python
 def registerMatchParticipants(dbname, table_name, sport, round_no, player_id1, player_id2):
 #+END_SRC

***** register scores
 #+BEGIN_SRC python
 def registerScores(dbname, table_name, match_no, home_score, away_score):
 #+END_SRC

***** log the results for a given round of a given tournament
 #+BEGIN_SRC python
 def log_round_results(dbname, tournament_name, round_of_tournament):
 #+END_SRC

***** count the number of players in a database?
 #+BEGIN_SRC python
 def how_many_players(dbname):
 #+END_SRC

***** set the Opponents Match Win for a player in the database
 #+BEGIN_SRC python
 def set_OMW(dbname, player_id):
 #+END_SRC

***** set the OMW for all the players in the database
 #+BEGIN_SRC python
 def set_all_OMW(dbname):
 #+END_SRC

***** create the player stnadings for a given tournament_name
 #+BEGIN_SRC python
 def new_playerStandings_alt(dbname, table_name, tournament_name):
 #+END_SRC

***** set up function for creaeting swiss pairings
 #+BEGIN_SRC python
 def naive_pairings(tournament_name):
 #+END_SRC

***** master function for creating swiss Pairings for a given round of a given tournament
 #+BEGIN_SRC python
 def naive_swissPairings(round_no, tournament_name):
 #+END_SRC

** actual full python final_project 'exceeds' in one block

*** all source
#+BEGIN_SRC python
def new_connect(dbname):
    dbname_string = "dbname={}".format(dbname)
    return psycopg2.connect(dbname_string)


def new_dbExecuteWrapper(query_string, dbname, extra=None):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string, extra)
    DB.commit()
    DB.close()


def new_dbExecuteRetrievalWrapper_allrows(dbname, query_string):
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query_string)
    rows = c.fetchall()
    DB.close()
    return rows


# SQL 'dsl' helpers

# used by keyword_statement_string, in turn used throughout
def update_statement_string(table_name):
    tb_name = table_name
    sql_keywords = """UPDATE """
    update_statement = sql_keywords + tb_name


def keyword_statement_string(table_name, sql_keyword):
    tb_name = table_name
    sql_keywords = sql_keyword + """ """
    update_statement = sql_keywords + tb_name + """ """
    return update_statement


# deletion
def new_deleteTable(dbname, table_name):
    tb_name = table_name
    sql_keywords = """DELETE FROM """
    query = sql_keywords + tb_name
    table_nm = (table_name,)
    new_dbExecuteWrapper(query, dbname)


def deletePlayers():
    new_deleteTable("tourney_practice", "playerz")


def deleteMatches():
    new_deleteTable("tourney_practice", "matchez")

# Not used in current implementation
# See 'how_many_players()'
# 
# def new_countPlayers(dbname, table_name):
#     DB = new_connect(dbname)
#     c = DB.cursor()
#     from_statement = keyword_statement_string(table_name, """FROM""")
#     query = "SELECT count(*)" + from_statement + ";"
#     c.execute(query)
#     row = c.fetchone()
#     row_item = list(row)
#     DB.close()
#     return int(row_item[0])

# refactor to allow substituting column names?


def new_registerPlayer(dbname, table_name, player_name, tournament_name):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(player_name, tournament_name)" +
             "VALUES (%s, %s);")
    new_dbExecuteWrapper(query, dbname, (player_name, tournament_name))

# ### IMPORTANT: which table/view and which columns??

## retrieval wrappers always make assumptions about columns
# orders only by points, returns only id and points for players
def new_playerStandings(dbname, table_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = ("SELECT player_id, points " +
             from_statement + "ORDER BY points DESC;")
    return new_dbExecuteRetrievalWrapper_allrows(dbname, query)


def registerMatch(dbname, table_name, tournament_name, round_of_tournament):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "(tournament_name, round)" +
             "VALUES (%s, %s);")
    new_dbExecuteWrapper(query, dbname, (tournament_name, round_of_tournament))


# use update_statement_string(table_name)???
def registerMatchParticipants(dbname, table_name, sport, round_no, player_id1, player_id2):
    participant_insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query2 = (participant_insert_statement + "(home, away)" + "VALUES (%s, %s);")
    new_dbExecuteWrapper(query2, dbname, (player_id1, player_id2))
    match_update_statement = keyword_statement_string("""matchez""", """UPDATE""")
    query1 = (match_update_statement +
              "SET tournament_name= (%s), round = (%s) WHERE tournament_name= 'none';")
    new_dbExecuteWrapper(query1, dbname, (sport, round_no))


def registerScores(dbname, table_name, match_no, home_score, away_score):
    insert_statement = keyword_statement_string(table_name, """INSERT INTO""")
    query = (insert_statement + "VALUES (%s, %s, %s);")
    new_dbExecuteWrapper(query, dbname, (match_no, home_score, away_score))


def log_round_results(dbname, tournament_name, round_of_tournament):
    query = "SELECT * FROM log_records(%s, %s)"
    new_dbExecuteWrapper(query, dbname, (round_of_tournament, tournament_name))

# a brittle way to obtain player ids?


def how_many_players(dbname):
    query = "select * from player_recordz;"
    return new_dbExecuteRetrievalWrapper_allrows(dbname, query)


def set_OMW(dbname, player_id):
    query = "SELECT * FROM set_omw(%s);"
    new_dbExecuteWrapper(query, dbname, (player_id,))


# inefficient to set the OMW for ALL players in ALL tournaments
def set_all_OMW(dbname):
    data = how_many_players(dbname)
    playaz = [n[0] for n in data]
    [set_OMW(dbname, n) for n in playaz]
    print("done")


# returns all columns and orders by TWO columns
def new_playerStandings_alt(dbname, table_name, tournament_name):
    from_statement = keyword_statement_string(table_name, """FROM""")
    query = "SELECT * " + from_statement + "WHERE tournament_name = (%s) ORDER BY points DESC, omw DESC;"
    DB = new_connect(dbname)
    c = DB.cursor()
    c.execute(query, (tournament_name,))
    rows = c.fetchall()
    DB.close()
    return rows
#    return new_dbExecuteRetrievalWrapper_allrows(dbname, query, tournament_name)

# conatins hard-coded db and table (the wrong table originally!)

def naive_pairings(tournament_name):
    pairings = []
    tables = new_playerStandings_alt("tourney_practice", "player_tables", tournament_name)
    [id1, id2, id3, id4, id5, id6, id7, id8] = [row[0] for row in tables]
    pairings = [(id1, id2), (id3, id4), (id5, id6), (id7, id8)]
    return pairings

# uses the hard-coding naive_pairings

def naive_swissPairings(round_no, tournament_name):
    next_round = naive_pairings(tournament_name)
    for pair in next_round:
        registerMatchParticipants("tourney_practice", "match_participants", tournament_name, round_no, pair[0], pair[1])

#+END_SRC
** SQL schema
[[file:additional-documentation/verbose_tournament.sql][file:~/Dropbox/AB-local/Documents-new-home/udacity-courses/fullstack/project2-submission/Project2/exceeds-spec/additional-documentation/verbose_tournament.sql]]
*** extended psql 'tournament.sql' schema of 'exceeds'
**** tables
#+BEGIN_SRC sql
CREATE TABLE playerz (

CREATE TABLE match_participants (

CREATE TABLE matchez(

CREATE TABLE score_results (

CREATE TABLE player_recordz (
#+END_SRC
**** views, functions and triggers
 #+BEGIN_SRC sql
 CREATE VIEW tournament_matches AS



 CREATE VIEW player_tables AS



 CREATE OR REPLACE FUNCTION initialize_player_rec() RETURNS TRIGGER AS $$



 CREATE TRIGGER initialize_player_rec



 CREATE OR REPLACE FUNCTION initialize_matchez() RETURNS TRIGGER AS $$



 CREATE TRIGGER initialize_match_participants
 #+END_SRC
**** functions to be used for logging player records
 #+BEGIN_SRC sql


 CREATE OR REPLACE FUNCTION log_draws(round_no integer, tournament_name text) RETURNS VOID AS $$



 CREATE OR REPLACE FUNCTION log_away_wins(round_no integer, tournament_name text) RETURNS VOID AS $$



 CREATE OR REPLACE FUNCTION log_away_losses(round_no integer, tournament_name text) RETURNS VOID AS $$



 CREATE OR REPLACE FUNCTION log_home_wins(round_no integer, tournament_name text) RETURNS VOID AS $$



 CREATE OR REPLACE FUNCTION log_home_losses(round_no integer, tournament_name text) RETURNS VOID AS $$
 #+END_SRC
**** update points
 #+BEGIN_SRC sql


 CREATE OR REPLACE FUNCTION update_points() RETURNS VOID AS $$

 #+END_SRC
**** functions used to set Opponents Match Wins
 #+BEGIN_SRC sql
 CREATE OR REPLACE FUNCTION players_matches (integer) RETURNS TABLE (opposing_player int) AS $$



 CREATE OR REPLACE FUNCTION player_OMW (integer) RETURNS TABLE (opponent int, opponent_OMW int) AS $$



 CREATE OR REPLACE FUNCTION set_omw (integer) RETURNS VOID AS $$
 #+END_SRC
**** the function used to log the records and tabulate points for players at each stage in a given tournament
 #+BEGIN_SRC sql
 CREATE OR REPLACE FUNCTION log_records(round_no integer, tournament_name text) RETURNS VOID as $$


 #+END_SRC
** tournament_test.py

Lastly, ~tournament_test.py~ is used to run a basic test of the
final_project.py code. All the code contained herein was provided by
Udacity ahead of time.

In the case of the 'exceeds specs,' there just was too much to write
explicit and thorough tests for; I began the process and was so
stymied that I dragged my feet for months. Ultimately, I provide a
basic "code journey" through one particular run of the "exceeds
specifications" version, showing that the extended code can handle
ties, multiple tournaments, and OMW ranking.
** Refactoring Considerations
There are a few places where hard-coding has meant that certain
assumptions are being made about the kinds of tournaments being used.

Specifically, column names are assumed by many if not most of the
functions here, though I took pains to make sure that different
database and table names could be used. That is, most functions use
various wrapper and abstraction helper functions that take database
and table names as arguments, thus allowing the user to more readily
expand the code base to work for his or her own databases (of course,
column names have not been similarly abstracted, due to time
constraints). 

In some ways, what I attempted was the beginning of a library for
tournament-making, SQL-based code (this can be seen most clearly in
the use of helper functions like =keyword_statement_string= which take
different table names and SQL keywords such as "FROM" and "INSERT
INTO"). This clearly was beyond the scope of the assignment, but was
illuminating nonetheless, especially in that it forced me to delve
into the more obscure and powerful corner of Postgres.



# The main problem is that the all important SQL function that sets
# player OMW is hard-coded to work for tournaments up to eight
# players.

Actually, do this in the python code. See set_all_OMW

